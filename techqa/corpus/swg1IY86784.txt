Title: IBM IY86784: TIMEOUTS ARE BEHAVING DIFFERENTLY BETWEEN TEST AND PRODUCTION - United States

Text:
AIX SUBSCRIBE
You can track all active APARs for this component.



APAR STATUS
 * CLOSED AS DUPLICATE OF ANOTHER APAR.
    
   
   

ERROR DESCRIPTION
 *  Customer is running TAM 5.1 FP13 on solaris 8. Here is the
   scenario:
   
   Action Taken: I received the following from the customer:
   
   
   In our production environment, we are running 5.1 FP13.  In this
   environment, we have an application that is complaining that the
    Pag
   webseal timeout parms that we have in place are not working.  We
   currently have a 2 hour timeout, (timeout = 7200) and an
   inactivity timeout of 30 minutes (inactive-timeout = 1800).
   They are
   claiming they can leave a session inactive for 45 minutes,
   come back and start working again without having to
   re-authenticate.
   They are also claiming they have worked for over 3 hours
   with a single browser and have not been forced to re-auth.
   
   My understanding is that the webseald.conf parms timeout and
   inactive-timeout control the session timeout and inactivity
   timeout
   for the webseal.  We are trying to find other applications to
   test and
   confirm what this first application is claiming.
   
   I am looking for suggestions at this point as to how to proceed.
   Also, could the browser's cache have any affect on this?
   
    Pag
   I have also attached a copy of webseald.conf from this
   environment for
   your reference.
   
   -------------------------------
   
   I researched the issue and found the following which I have
   forwarded to
   the customer:
   
   Here is the DCF:
   
   Problem(Abstract)
   The inactive-timeout/timeout will not always take effect EXACTLY
   at the time specified in webseald.conf..
   
   For example, if you have the following settings..
   
   
   [session]
   timeout=43200
   inactive-timeout=3600 (60 min.)
   
   You will notice that re-authentication due to inactivity will
   occur somewhere around 60 - 75 min. of inactivity. (with a delay
   of couple of min. from what has been set in the
   inactivie-timeout parameter)
   
   
   L3 responded with:
   Cause
   The session timeout mechanism is a separate thread that checks
   for inactivity and total durations against every session in
   WebSEAL's cache.
   
   Because the operations involved are relatively expensive and
   WebSEAL may have many sessions to check, the session timeout
   thread does not make continuous, or even frequent checks against
   the session cache.
   
   The thread sleeps for 1/4 of either inactive-timeout or timeout,
   whichever is shorter. When its done sleeping, it runs through
   every session to flag the expired ones, then goes back to sleep.
   
   So if a user begins his session shortly after a period during
   which the session timeout thread made its last check, his
   session will not timeout until after the next four checks are
   made. It appears inconsistent because testers have no way of
   knowing where in the session timeout thread's sleep/check cycle
   they have initiated their session lifetime. Furthermore, they
   don't know how long it has been since the session has actually
   expired.
   
   inactive
   |<-----timeout----->|
   ____|____|____|____|____|____|
   a  b                   c
   
   
   A monospace font will display the above diagram correctly.
   1) A session is initiated, and further activity ceases.
   2) The session timeout thread notes the beginning of the
   session's inactivity.
   3) The fourth timeout check after inactivity began arrives, and
   the timeout
   thread flags the session. A grace period preserves the
   session temporarily,
   should the user re-authenticate.
   4) The user makes another request and discovers his session has
   expired.
   
   The letters a, b, and c signify points on a timeline. Each
   vertical bar represents the point where the thread checks for
   inactive-timeout. You will observe c - a can be significantly
   larger than c - b, the inactive-timeout.
   
   
   Lifetime and Inactive timers are both handled by the same
   thread, using
   the same '1/4 of shortest setting' method to calc the intervals
   at which
   the thread runs.  All this is within the sessionID cache, which
   should
   effect all authentication methods (assuming sessionid are being
   used).
   With the following:
   
   timeout = 7200
   inactive-timeout = 7200 or 0 or not present
   
   Then the thread would run once every 30 minutes.  If the user
   logged in
   one second after the last run of the thread then the max login
   time
   would be 3 hours minus 2 seconds.  This is caused by the
   inheirent lag
   in executation time of the timeout thread itself, as the real
   (observed)
   interval is equal to the combination of 'calculated delay
   interval' and
   'timeout thread executation time'.  This results in a max lag
   (or login
   time) of:
   
   timeout_value + (2 x (calculated_delay_interval - 1))
   or
   7200 + (2 x ( 1800 -1)) = 10798 seconds = 2 hours 59 minutes 58
   seconds
   
   
   
   I have collected a system_status from one of the systems in test
   and one in production.
   
   
    
   
   

LOCAL FIX

PROBLEM SUMMARY

PROBLEM CONCLUSION

TEMPORARY FIX

COMMENTS
 *   Per Jim B, duplicate of IY68773 [http://www-01.ibm.com/support/docview.wss?uid=swg1IY68773].
   
   
    
   
   

APAR INFORMATION
 * APAR NUMBER
   IY86784
   
   
 * REPORTED COMPONENT NAME
   ACCESS MGR EDGE
   
   
 * REPORTED COMPONENT ID
   5724C0810
   
   
 * REPORTED RELEASE
   510
   
   
 * STATUS
   CLOSED DUA
   
   
 * PE
   NoPE
   
   
 * HIPER
   NoHIPER
   
   
 * SPECIAL ATTENTION
   NoSpecatt
   
   
 * SUBMITTED DATE
   2006-07-11
   
   
 * CLOSED DATE
   2006-07-21
   
   
 * LAST MODIFIED DATE
   2006-07-21
   
   

 * APAR IS SYSROUTED FROM ONE OR MORE OF THE FOLLOWING:
   
   
   
 * APAR IS SYSROUTED TO ONE OR MORE OF THE FOLLOWING:
   
   
   

FIX INFORMATION
 * FIXED COMPONENT NAME
   ACCESS MGR WEBS
   
   
 * FIXED COMPONENT ID
   5724C0811
   
   

APPLICABLE COMPONENT LEVELS