Title: IBM How to recover Content Manager OnDemand for z/OS collection id nodes mistakenly deleted from storage set - United States

Text:
document not found TECHNOTE (FAQ)

QUESTION
 How can nodes that were mistakenly deleted from a storage set via the admin client, which still have loaded report data and indexes associated with them, be restored? 

ANSWER
As long as the deleted node was not re-added to the storage set using the admin client, and new report data subsequently loaded to the re-added node, the following procedure can be used:
If the previously loaded report data resides in OAM, all that was effectively deleted when the admin deleted the collection ids were the corresponding rows in the ARSNODE table, and all indexing data for any application groups loaded to those nodes, and the corresponding report objects stored in OAM, are still there. As a result restoring the missing rows in ARSNODE will make the OAM report objects retrievable through the application group indexing data again. As of DB2 V7, it is possible to do a 
selective UNLOAD of the missing subset of rows from a DB2 image copy of the ARSNODET tablespace taken before the delete of the rows in question, Then reload them to the live ARSNODE table. Given you still have such an image copy available, this solution should work for you. 

Here is sample jcl to unload selected rows from a specific image copy of the ARSNODET tablespace. If your image copy dataset names are z/OS cataloged GDG datasets, the COPYDSN DD below should specify the absolute GDG number in the dataset name, as that is where it will also be stored in the DB2 SYSCOPY catalog table. 
........................................................................ 
//JOB1 JOB ...... 
//UNLOAD EXEC PGM=DSNUTILB,REGION=0M, 
// PARM='<ssid>,UNLOAD' 
//STEPLIB DD DISP=SHR,DSN=DSN.DB2V810.SDSNLOAD 
//SYSPRINT DD SYSOUT=* 
//UTPRINT DD SYSOUT=* 
//SYSUDUMP DD SYSOUT=* 
//COPYDSN DD DSN=<ARSNODET ts ic dataset name>,DISP=OLD 
//SYSREC DD DSN=<unload dataset name>, 
// DISP=(,CATLG,DELETE), 
// UNIT=SYSDA,SPACE=(TRK,(1,1),RLSE) 
//SYSPUNCH DD SYSOUT=* 
//SYSIN DD * 
UNLOAD TABLESPACE ARSDBASE.ARSNODET 
FROMCOPYDDN COPYDSN 
FROM TABLE ARSSERVR.ARSNODE 
WHEN (NID IN (<nid1>,<nid2>,<nid3>,...<nid30)) 
// 
........................................................................ 

And below you will find sample jcl to reload those just unloaded rows to the live ARSNODE table. 

Note that in the example I copied the DDL that was generated to the SYSPUNCH DD by the unload above. The only change I made to that DDL before running my test was to specify LOG YES rather than LOG NO so that the tablespace would not be put in COPYPEND status on completion. With LOG NO an image copy would need to be taken afterwards to make the newly loaded data fully recoverable and take the tablespace out of COPYPEND status. 

Also note, depending on when you want to run this, the LOAD utility defaults to use SHRLEVEL NONE, which would preclude any other access to the table until after the load completes (and if you run with LOG NO, until after a new image copy is taken). You can optionally modify the DDL to specify SHRLEVEL CHANGE to allow concurrent read/write access to the table, and thereby not lock out users while the load is running, but I recommend you review the considerations for that option of the LOAD 
utility in the DB2 V8 Utility Guide, which you can find at the following url: 

http://publib.boulder.ibm.com/epubs/pdf/dsnugj19.pdf [http://publib.boulder.ibm.com/epubs/pdf/dsnugj19.pdf] 

Finally note that the WHEN statement generated in the DDL by the unload, along with one or two other statements may vary slightly from what will be generated when the unload job is run at your site, and you should use the DDL generated by your unload as a starting point to be incorporated in your reload job, adjusting to make any changes desired to the LOG and SHRLEVEL options discussed above. 

........................................................................ 
//JOB2 
//RELOAD EXEC PGM=DSNUTILB,REGION=0M, 
// PARM='<ssid>,RELOAD' 
//STEPLIB DD DISP=SHR,DSN=<SDSNLOAD> 
//SYSPRINT DD SYSOUT=* 
//UTPRINT DD SYSOUT=* 
//SYSUDUMP DD SYSOUT=* 
//SORTWK01 DD UNIT=SYSDA,SPACE=(TRK,(1,1),RLSE) 
//SORTWK02 DD UNIT=SYSDA,SPACE=(TRK,(1,1),RLSE) 
//SORTWK03 DD UNIT=SYSDA,SPACE=(TRK,(1,1),RLSE) 
//SYSUT1 DD UNIT=SYSDA,SPACE=(TRK,(1,1),RLSE) 
//SORTOUT DD UNIT=SYSDA,SPACE=(TRK,(1,1),RLSE) 
//SYSREC DD DSN=<unload dataset name>, 
// DISP=SHR 
//SYSIN DD * 
LOAD DATA INDDN SYSREC LOG YES RESUME YES 
EBCDIC CCSID(00037,00000,00000) 
SORTKEYS 3 
INTO TABLE 
"ARSSERVR". 
"ARSNODE" 
WHEN(00001:00002) = X'008D' 
( "SID" 
POSITION( 00003:00006) INTEGER 
, "NID" 
POSITION( 00007:00008) SMALLINT 
, "NAME" 
POSITION( 00009:00070) VARCHAR 
, "DESCRIPTION" 
POSITION( 00071:00192) VARCHAR 
, "LOGON" 
POSITION( 00193:00322) VARCHAR 
, "PASSWD" 
POSITION( 00323:00452) VARCHAR 
, "SERVER" 
POSITION( 00453:00708) VARCHAR 
, "STATUS" 
POSITION( 00709:00710) SMALLINT 
, "SEC_NID" 
POSITION( 00711:00712) SMALLINT 
, "UPD_USERID" 
POSITION( 00714:00843) VARCHAR 
NULLIF(00713)=X'FF' 
, "UPD_DATE" 
POSITION( 00845:00848) INTEGER 
NULLIF(00844)=X'FF' 
) 
// 
........................................................................ 


If however the missing nodes were re-added to the storage set using the admin client, new internal node ids would have been assigned. If new report data has also subsequently been loaded to the re-added nodes, they are now tied to their corresponding indexing data through the new node ids. So those newly loaded reports must first be unloaded. Then run following DB2 sql to change the nids for the re-added nodes back to the original nids:

update arsservr.arsnode
set nid = <original nid>
where nid = readded nid;

Note that the original nid's can be determined from the OnDemand System Log entries that reflect their deletion; i.e. "Info No 93 StorageNode Delete...." entries

The report that were loaded to the new nids and then unloaded, can now be reloaded.