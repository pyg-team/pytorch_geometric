Title: IBM How and when to use create index - United States

Text:
Netezza; NPS; IBM Netezza TECHNOTE (FAQ)

QUESTION
 How do I use the admin privilege 'create index'? 

ANSWER
This provides information on the admin privilege of create index and why you may need to grant this privilege to a particular user.
Used to support the PKRI script, commonly used to verify referential integrity.

As you know, by design, PK and FK are not enforced in Netezza since they would significantly slow down write operations...something you absolutely don't want on a terascale architecture whose claim to fame is extreme performance. However, the references are kept in the catalog, so you can automate procedures, as a number of our customers have, that check these constraints following write transactions in an automated manner such as performed by the nz_ri script. Additionally, being able to specify them with ANSI-92 syntax makes life easier for some third-party tools that have no choice but to generate constraint SQL.

Here's the syntax:


 * system(admin)=> \h create table Command: CREATE TABLE
 * 
 * Description: Creates a new table
 * 
 * Syntax:
 * 
 * CREATE [ TEMPORARY | TEMP ] TABLE table_name (
 * 
 * { column_name type [ column_constraint [ ... ] ]
 * 
 * | table_constraint } [, ... ]
 * 
 * ) [ DISTRIBUTE ON ( column [, ...] ) ]


where column_constraint can be: 
 * { NOT NULL | NULL | UNIQUE | PRIMARY KEY | DEFAULT value |
 * 
 * REFERENCES table [ ( column ) ]
 * 
 * }


and table_constraint can be: 
 * { PRIMARY KEY ( column_name [, ... ] ) |
 * 
 * FOREIGN KEY ( column_name [, ... ] ) REFERENCES table [ ( column [, ... ] ) ]
 * 
 * }


Note: The system permits and maintains PRIMARY KEY, DEFAULT, FOREIGN KEY, UNIQUE, 
and REFERENCES. The NPS does not support constraint checks and referential integrity. 
It is up to the user to ensure constraint checks and referential integrity. 


You need to grant the privs and use ANSI-92 SQL to specify the constraints. First, you need this admin privilege to be allowed to create a table 
 * GRANT CREATE TABLE TO {user} ;


To create a table -- with a primary key defined -- you will also need this admin privilege: 
 * GRANT CREATE INDEX TO {user} ;


For example: 
 * create table test_table (col1 int, col2 int, col3 int, col4 int, primary key (col3, col1));


If you then do a " \d ", you will see that a postgres index/object is also created along with the table. 
 * List of relations
 * 
 * Name | Type | owner
 * 
 * -----------------+-------+-----------
 * 
 * test_table | table | test_user
 * 
 * test_table_pkey | index | test_user
 * 
 * (2 rows)


You can find out what column(s) comprise the primary key by doing a " \d " on the index itself: 
 * \d test_table_pkey
 * 
 * Index "test_table_pkey"
 * 
 * Attribute | Type
 * 
 * -----------+---------
 * 
 * col3 | integer
 * 
 * col1 | integer
 * 
 * unique (primary key)
 * 

But what if you want to create a table -- that includes foreign key references? This seems to require yet another administrative privilege -- but one which you're not allowed to specify/grant! How then to get around this? 

First, grant ALL administrative privileges to the user. Privileges are basically just a bit mask -- you can turn all bits on at once (GRANT ALL ADMIN) or turn them on individually. By turning them all on at once, you're also turning on some hidden/inaccessible bits. 
 * system(admin)=> grant all admin to jeff;
 * 
 * GRANT< br/>
 * 
 * system(admin)=> \dpu jeff
 * 
 * User object permissions for user 'jeff'
 * 
 * DBName | ObjName | L S I U D T L A D B | D G U T V I B R C L G S H
 * 
 * -------+---------+---------------------+--------------------------
 * 
 * global | global | | X X X X X X X X X X X X X
 * 
 * (1 rows)
 * 
 * (L)ist (S)elect (I)nsert (U)pdate (D)elete (T)runcate (L)ock (A)lter (D)rop a(B)ort
 * 
 * (D)atabase (G)roup (U)ser (T)able (V)iew (I)ndex (B)ackup (R)estore re(C)laim (L)oad (G)enstats (S)ystem (H)ardware


Next, selectively revoke the admin privileges that that user does not need to have -- leaving CREATE TABLE and CREATE INDEX there (and any other ones that the user should have). This will "leave on" some of those hidden privileges/bits that you need to have in order to use foreign key references. 
 * system(admin)=> revoke database, group, user, view, backup, restore, reclaim, load, genstats, system, hardware from jeff;
 * 
 * REVOKE
 * 
 * system(admin)=> \dpu jeff
 * 
 * User object permissions for user 'jeff'
 * 
 * DBName | ObjName | L S I U D T L A D B | D G U T V I B R C L G S H
 * 
 * -------+---------+---------------------+--------------------------
 * 
 * global | global | | X X
 * 
 * (1 rows)
 * 
 * (L)ist (S)elect (I)nsert (U)pdate (D)elete (T)runcate (L)ock (A)lter (D)rop a(B)ort
 * 
 * (D)atabase (G)roup (U)ser (T)able (V)iew (I)ndex (B)ackup (R)estore re(C)laim (L)oad (G)enstats (S)ystem (H)ardware


So, even though it doesn't look any different, user 'jeff' can now create tables WITH primary key and WITH foreign key references. 
 * system(jeff)=> create table a1 (col1 int);
 * 
 * CREATE TABLE
 * 
 * system(jeff)=> create table a2 (col1 int primary key);
 * 
 * CREATE TABLE
 * 
 * system(jeff)=> create table a3 (col1 int, col2 int primary key, foreign key (col1) references a2 (col1));
 * 
 * CREATE TABLE



HISTORICAL NUMBER
 NZ735049