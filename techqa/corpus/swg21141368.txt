Title: IBM Troubleshooting Java agent message 'Error cleaning up agent threads' - United States

Text:
java; java agent; troubleshooting script; Error cleaning up agent threads; threadgroup TECHNOTE (FAQ)

QUESTION
There can be a number of reasons why a Java agent might return the following message on the server console: 

 * 
 * 


In most cases, the Lotus Domino server is unable to clean up or destroy a thread that was spawned as a result of the agent execution. How can you troubleshoot this problem? 
ANSWER
What follows is discussion about a method you can use to determine what threads are being spawned in the agent, which can give you insight into why Domino may not be able to destroy such a thread 

When executing a Java Agent on the server (either Server, AMgr, or HTTP), Domino creates a thread group with which additional dynamically spawned threads are associated. These threads can either be spawned by Domino code or other external code. 

When the agent terminates, Domino must ensure that all spawned threads are terminated, even if they are non-Domino threads. To do this, Domino steps through the Thread Group it created when loading the agent, and attempts to terminate or destroy all threads. If it finds a thread it cannot destroy, then it produces the message "Error cleaning up agent threads." This message means that a dynamically spawned thread has been left behind, possibly resulting in a thread leak, which could cause the server to exhaust its memory. 

Many conditions can result in this case, some of which are benign, others of which are not. For instance, if agent code declares a Java Thread, but does not start that thread, Domino will return an error when attempting to destroy it. However, since the thread was never started, this does not actually cause a problem. 

Other cases include the following: 

 * Not recycling a remote Corba Notes Session. Because a separate thread is spawned to handle the IIOP connection, if you do not recycle that session explicitly, then the thread will remain active. This will cause an error when Domino attempts to destroy the thread. This condition can cause moderate problems, but once the remote IIOP server times out the connection, this thread will terminate on its own. 
 * Using a third-party thread pool or connection pool that assumes persistent threads (namely, threads will remain persistent over many executions of the agent). Similar to the above case, if such threads are active on a network connection or some other persistent resource, Domino will be unable to destroy them, resulting in the message "Error cleaning up agent threads." Over time, there may be a build up of threads, resulting in a low memory condition.


To troubleshoot these cases and determine what threads were spawned as a result of executed agent code, designers and administrators can use the core Java API to print out information about each thread in the current thread group. Below is a sample routine that can be called to list the threads of a specific thread group. If no thread group is passed in, it assumes the current thread group: 


public static void dumptg (ThreadGroup tg)
{
// First, get our thread group
if (tg == null)
{
// none specified, assume current thread group
tg = Thread.currentThread().getThreadGroup();
}

// display the threadgroup name and object id
System.out.println("ThreadGroup "+tg.getName()+ ", objid = "+tg.hashCode());

// display the threadgroup's number of active subgroups
System.out.println(" subgroups = "+tg.activeGroupCount());

// get and display the number of active threads in this threadgroup and all subgroups
int tcount = tg.activeCount();
System.out.println(" total threads = "+tcount);

// allocate an array big enough to hold the number of threads
Thread[] arr = new Thread[tcount];

// fill in the array with the active threads (include subgroups)
int num = tg.enumerate(arr,true);

// display how many were stored.
System.out.println("\nThread Name, ThreadID, ThreadGroup");

// display the name, id and owning threadgroup of each thread
for (int i = 0; i<num; i++)
{
System.out.println(arr[i].getName()+", "+
arr[i].hashCode()+", "+
arr[i].getThreadGroup().getName());
}
} 

 

This routine can be called from an agent in the following manner: 


public void NotesMain ()
{
//other code here

System.out.println("Dump the current threadgroup:\n");
dumptg(null);
}

The resulting output might look something like this:


 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * ip address
 * 


In this case, three threads are present in the thread group (with no subgroups), where UTG stand for User Thread Group: 
1). AgentThread: RemoteAgent - UTG: RemoteAgent 
2). RecycleThread, 7889714, UTG: RemoteAgent 
3). JavaIDL Reader for ip address:63148, UTG: RemoteAgent 

Notice thread number three is interacting with the remote IIOP server on port 63148, which in one case was a clue that the agent was not recycling the remote session. 

A designer can also attempt to bootstrap up to the parent thread group, and dump out all thread groups with the following code: 

System.out.println("\n\nNow dump all threadgroups:\n"); 
ThreadGroup top = Thread.currentThread().getThreadGroup(); 
while (top.getParent() != null) 
{ 
top = top.getParent(); 
} 

dumptg(top); 

This code might be used in a case other than within NotesMain() in an agent execution, for instance if you think you may belong to a subgroup. However, in the case of a Java Agent, you will encounter a Java Security Exception when attempting to get a handle to the parent thread group. This exception occurs because access is not allowed to the parent group within the agent context, since this might expose thread not within the agent context. 

Once you have used this method to dump all threads in the agent thread group, you can analyze the thread name, thread ID, and ThreadGroup information for clues as to what code may be involved, or why a thread might not be getting destroyed.