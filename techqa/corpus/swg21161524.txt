Title: IBM ICM transactions: Handling explicit transactions after a failed operation - United States

Text:
Explicit Transaction; failed operation; rollback; transaction behavior TECHNOTE (FAQ)

QUESTION
 When you catch an error thrown by the API in the middle of an explicit transaction, you are obligated to call rollback() to end the explicit transaction in progress. As soon as the operation fails, the transaction's state changes to “Failed Explicit Transaction” mode. This means that any operation after the exception will fail, including subsequent startTransaction() or commit() calls. 

ANSWER
With Version 8.2 fix pack 7 or later, the behavior available for handling explicit transactions has changed. The following document outlines correct handling when transaction behavior is configured to remain in a failed state. For more information about transaction behavior for failed transactions, refer to the updated STransactionsICM.java API Education Sample available with Version 8.2 fix pack 7 or later. 

All of the API calls made between a DKDatastoreICM::startTransaction() and either DKDatastoreICM::commit() or DKDatastoreICM::rollback(), are treated as one transaction. When you catch an error thrown by the API in the middle of an explicit transaction, you are obligated to call rollback() to end the explicit transaction in progress. As soon as the operation fails, the transaction's state changes to “Failed Explicit Transaction” mode. This means that any operation after the exception will fail, including subsequent startTransaction() or commit() calls. 


The following steps explain what will happen when you attempt various operations when working with an explicit transaction and an API operation returns in error. 

 1. Start an explicit transaction (DKDatastoreICM::startTransaction()). 
 2. Try to delete an item that is locked by another user (DKDDO::del()). It should fail. You can catch and ignore this exception for the purposes of this demonstration. Typically if you did not expect an operation to fail, you should handle the failure. This time, we achieved a failed transaction which should now be in a failed state. 
 3. Try to delete another ddo that exists that you would normally have access to. This fails since it is an operation within a failed explicit transaction. 
 4. Try to start an explicit transaction. This fails since it is an operation within a failed explicit transaction. 
 5. Commit the current explicit transaction. This fails since it is an operation within a failed explicit transaction. 
 6. Rollback the current explicit transaction. This succeeds and would end the failed state of the explicit transaction. 
 7. Validate that items represented by the two DKDDO objects that you called delete on still exist, since the transaction was successfully rolled back.


This code example assumes that DKDDO ddo1, ddo2, and DKDatastoreICM dsICM are already defined, and that deleting ddo2 will fail because it is checked out by another user. 

dsICM.startTransaction(); 

boolean error = false; 

// The following delete operation is expected to fail because the 
// ddo is checked out by another user 
try {  * ddo2.del();

} catch (Exception e) {  * System.out.println(
 * "As expected caught exception deleting ddo2.");
 * 
 * error = true;

} 

// Delete of ddo1 will fail (even though it is a genuine operation) 
// indicating that a failed explicit transaction is in progress 

try {  * ddo1.del();
 * 
 * // If we did not get an exception while deleting ddo1 then
 * 
 * // the demonstration failed. Throw an exception.
 * 
 * throw new Exception("Starting a transaction within a failed explicit transaction did not fail as expected");

} catch (DKException e) {  * System.out.println("Caught Exception As Expected: " + e.getMessage());

} 

// Starting a new transaction will fail since the existing 
// explicit transaction is still open and failed. We should 
// get another exception. 
try {  * dsICM.startTransaction();
 * 
 * // If we did not get an exception, the demonstration failed.
 * 
 * throw new Exception("Starting an explicit transaction within a failed explicit transaction did not fail as expected");

} catch (DKException e) {  * System.out.println("Caught Exception As Expected: " + e.getMessage());

} 

// Try to commit the current failed transaction. It should 
// return in error. 
try {  * dsICM.commit();
 * 
 * // If we did not get an exception after a commit then the
 * 
 * // demonstration failed.
 * 
 * throw new Exception("Commit of an explicit transaction within a failed explicit transaction did not fail as expected");

} catch (DKException e) {  * System.out.println("Caught Exception As Expected: " + e.getMessage());

} 

try {  * // Finally, rollback. This will reset the current failed
 * 
 * // explicit transaction. It should not throw any
 * 
 * // exceptions.
 * 
 * dsICM.rollback(); 

} catch (Exception e) {  * System.out.println(
 * "Unexpected Exception Caught: "+e.getMessage()
 * ));
 * 
 * throw e

} 



Cross reference information Segment Product Component Platform Version Edition Enterprise Content Management Content Manager Retrieve Issues AIX, Solaris, UNIX, Windows 2000, Windows NT 8.2