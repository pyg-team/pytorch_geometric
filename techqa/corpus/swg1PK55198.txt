Title: IBM PK55198: APPLICATION HANGS WHILE HEAPDUMP AND JAVACORE GENERATION USING JVMRI PROFILER - United States

Text:
AIX SUBSCRIBE
You can track all active APARs for this component.



APAR STATUS
 * CLOSED AS PROGRAM ERROR.
    
   
   

ERROR DESCRIPTION
 *  Error Message: Application hangs without any exception
   .
   Stack Trace: We got wrong stack traces because jdump tool itself
   got confused when using jVMRI profiler.
   Traces
   (cc)=027CCB83  at  MemoryLeak.main  (<OSB>Ljava/lang/String;)V
   static  MMI2JIT
       unwinding (old_esp=0007FDE8 old_eip=027CCB83)
   old_mb=01FAD5CC
   *** check ***  unknown pattern (CA 7C 02) at 027CCC45
   *** check ***  method prolog not found (cc_start=027BCC1F,
   cc_limit=027CCC1F, candid=101E18D8)
   (cc)=027CCC45  at  (*** check ***  cc marker not found)
       unwinding (old_esp=0007FDE8 old_eip=027CCC45)
   *** check ***  unknown pattern (CA 7C 02) at 027CCC45
   *** check ***  stack trace possibly terminated
       --- Monitors Held ---
       object 002BBEA0 (java/lang/ref/Reference$Lock@102029E8)
       system 0202FF60 (JITC CHA lock)
       system 00038A30 (Free Class Loader Cache Entry lock)
       system 000389E8 (IO lock)
       system 000388C8 (Sleep lock)
       system 00038760 (Heap lock)
       system 000386D0 (Monitor Cache lock)
       system 000387A8 (JNI Pinning lock)
       system 00038718 (JNI Global Reference lock)
       system 00038688 (Binclass lock)
       system 00036A78 (Thread queue lock)
   .
   Customer provided the test case using which we can reacreate the
   problem locally
   
   
    
   
   

LOCAL FIX
 *  no workaround
   
   
    
   
   

PROBLEM SUMMARY
 *  Application hangs while heapdump and javacore generation using
   JVMRI profiler"
   Application hangs without any exception
   We got wrong stack traces because jdump tool itself got confused
   when using jVMRI profiler.
   Traces
   (cc)=027CCB83  at  MemoryLeak.main  (<OSB>Ljava/lang/String;)V
   static  MMI2JIT
       unwinding (old_esp=0007FDE8 old_eip=027CCB83)
   old_mb=01FAD5CC
   *** check ***  unknown pattern (CA 7C 02) at 027CCC45
   *** check ***  method prolog not found (cc_start=027BCC1F,
   cc_limit=027CCC1F, candid=101E18D8)
   (cc)=027CCC45  at  (*** check ***  cc marker not found)
       unwinding (old_esp=0007FDE8 old_eip=027CCC45)
   *** check ***  unknown pattern (CA 7C 02) at 027CCC45
   *** check ***  stack trace possibly terminated
       --- Monitors Held ---
       object 002BBEA0 (java/lang/ref/Reference$Lock@102029E8)
       system 0202FF60 (JITC CHA lock)
       system 00038A30 (Free Class Loader Cache Entry lock)
       system 000389E8 (IO lock)
       system 000388C8 (Sleep lock)
       system 00038760 (Heap lock)
       system 000386D0 (Monitor Cache lock)
       system 000387A8 (JNI Pinning lock)
       system 00038718 (JNI Global Reference lock)
       system 00038688 (Binclass lock)
       system 00036A78 (Thread queue lock)
   
   
    
   
   

PROBLEM CONCLUSION
 *  This defect will be fixed in:
   1.4.2 SR10
   .
   1. The Main thread has an execution environment  and it creates
   a native thread "rasThread-1".
    The "rasThread-1"  calls the JVMRI API GenerateHeapdump to
   generate the heapdump.   Before generating the heapdump, it
   calls GC.
    The "rasThread-1"  uses its parent thread's execution
   environment for doing GC, though it has its own execution
   environment.
   So during GC, the "rasThread-1" acquires the locks like Queue
   Lock, JNI Pinning Lock etc,
    whose monitor structure sys_mon_t  points to the thread id
   pointed by "rasThread-1"'s parent.
     This is because we the thread ID from the execution
   environment, and in this it is the parent thread's execution
   environment,
   and therefore, we would get the parent thread id.
   2. However, when we go further to suspend the threads, the
   "rasThread-1" tries to get the
   SYS_QUEUE_LOCK (which is nothing but the QUEUE_LOCK) and here it
   uses its own sys_thread_t and
    hence can not get the SYS_QUEUE_LOCK as the monitor structure
   states that the parent thread is holding the SYS_QUEUE_LOCK and
   thus the "rasThread-1" gets blocked on SYS_QUEUE_LOCK.
   3. On the other side, the parent thread attempts to print and
   during this process, it requires SYSTEM_HEAP lock.
      The "rasThread-1" acquires the SYSTEM_HEAP lock during GC
   using another API LOCK_LOCAL, which actually gets the
   sys_thread_t pointer from
   the current execution environment (eeGetCurrent()).
     The eeGetCurrent() returns the execution environment of the
   "rasThread-1"  and therefore the sys_mon_t structure for
   SYSTEM_HEAP lock rightly
   points to the sys_thread_t id of the "rasThread-1".   Therefore
   the parent thread gets blocked on SYSTEM_HEAP.
   Ideally speaking we should always get the execution environment
   of the thread that is acquiring the locks.
     In this case, it should be the execution environment of the
   "rasThread-1".
    The possible fix is that when we pass the execution environment
   for the GC call in rasGenerateHeapdump API,
    we should pass the eeGetCurrent() which actually points to the
   execution environment  of the"rasThread-1"
   instead of the parent thread's execution environment  obtained
   from eeGetFromJNIEnv call.
   Conclusion:
   ==============
   I applied this fix and ran the testcase, and was able to
   generate the Heapdump.    I put the same fix in
   rasGenerateJavacore and I was able to generate the Javacore as
   well.
   .
   To obtain the fix:
   Install build 20080229 or later
   
   
    
   
   

TEMPORARY FIX
 *  No
   
   
    
   
   

COMMENTS

APAR INFORMATION
 * APAR NUMBER
   PK55198
   
   
 * REPORTED COMPONENT NAME
   JAVA(1.3/1.4 CO
   
   
 * REPORTED COMPONENT ID
   5648C9800
   
   
 * REPORTED RELEASE
   42A
   
   
 * STATUS
   CLOSED PER
   
   
 * PE
   NoPE
   
   
 * HIPER
   NoHIPER
   
   
 * SPECIAL ATTENTION
   NoSpecatt / Xsystem
   
   
 * SUBMITTED DATE
   2007-10-23
   
   
 * CLOSED DATE
   2008-03-28
   
   
 * LAST MODIFIED DATE
   2008-03-28
   
   

 * APAR IS SYSROUTED FROM ONE OR MORE OF THE FOLLOWING:
   
   
   
 * APAR IS SYSROUTED TO ONE OR MORE OF THE FOLLOWING:
   
   
   

FIX INFORMATION
 * FIXED COMPONENT NAME
   JAVA(1.3/1.4 CO
   
   
 * FIXED COMPONENT ID
   5648C9800
   
   

APPLICABLE COMPONENT LEVELS
 * R42A PSN
   UP
   
   
 * R42L PSN
   UP
   
   
 * R42W PSN
   UP
   
   
 * R420 PSN
   UP