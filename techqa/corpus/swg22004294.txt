Title: IBM Insert into a trigger with RID table may receive SQL0901N - United States

Text:
 TECHNOTE (TROUBLESHOOTING)

PROBLEM(ABSTRACT)
 Insert into a trigger with RID table may receive SQL0901N 

SYMPTOM
Below message is returned to insert: 

----
DB21034E The command was processed as an SQL statement because it was not a
valid Command Line Processor command. During SQL processing it returned:
SQL0901N The SQL statement or command failed because of a database system
error. (Reason "deepcolfetch of old columns for an update did not resolve".)
SQLSTATE=58004
----

Below message is logged at db2diag.log:
----
2017-06-02-02.41.16.548937-240 I158883A908 LEVEL: Severe
PID : 33620388 TID : 11139 PROC : db2sysc
INSTANCE: db2inst1 NODE : 000 DB : DB1
APPHDL : 0-284 APPID: *LOCAL.hidehy.170602064133
AUTHID : DB2INST1 HOSTNAME: db2inst1
EDUID : 11139 EDUNAME: db2agent (DB1)
FUNCTION: DB2 UDB, relation data serv, sqlrr_dump_ffdc, probe:250
DATA #1 : SQLCA, PD_DB2_TYPE_SQLCA, 136 bytes
sqlcaid : SQLCA sqlcabc: 136 sqlcode: -901 sqlerrml: 57
sqlerrmc: deepcolfetch of old columns for an update did not resolve
sqlerrp : SQLNS01E
sqlerrd : (1) 0x00000000 (2) 0x00000000 (3) 0x00000000
(4) 0x00000000 (5) 0xFFFFFF9C (6) 0x00000000
sqlwarn : (1) (2) (3) (4) (5) (6)
(7) (8) (9) (10) (11)
sqlstate:
----


RESOLVING THE PROBLEM
Here is a problem reproducible sample shell script for reference: 

-----
#
db2 -v drop db db1
db2 -v create db db1
db2 -v connect to db1
db2 -v "create table db2inst1.tab1(col1 CHAR(10))"
db2 -v "create table db2inst1.tab2(col1 BIGINT not null, primary key (col1))"
db2 -v "create trigger trigger_tr after insert on db2inst1.tab1
referencing new table as new_tr1 for each row mode db2sql
insert into db2inst1.tab2 (col1)
values ((select RID(new_tr1) from new_tr1))"
db2 -v "insert into db2inst1.tab1(col1) values ('a')"
db2 -v terminate
-----

Here is snippet of documentation for reference:
* RID and RID_BIT scalar functions
https://www.ibm.com/support/knowledgecenter/SSEPGG_11.1.0/com.ibm.db2.luw.sql.ref.doc/doc/r0050679.html [https://www.ibm.com/support/knowledgecenter/SSEPGG_11.1.0/com.ibm.db2.luw.sql.ref.doc/doc/r0050679.html]
----
>>-+-RID-----+--(--+------------------+--)--------------------->< 
'-RID_BIT-' '-table-designator-' 

table-designator

Uniquely identifies a base table, view, or nested table expression (SQLSTATE 42703).
----

The documentation has not clearly defined if the table-designator could be a trigger 
transition table or not.

For DB2 family compatibility reason, the RID(transition-table) is defined as the row ID
of the *transition table*, which is NOT necessarily the same as the row ID of the newly 
inserted rows in the target table of the triggering insert/update/delete statement.

From above sample, it is expecting that RID(new-transition-table) will return the RID of
the newly inserted rows in the target table, which is not the case here.

From the design documents, the designed use case of RID() function is for Optimistic 
Locking, which allows more concurrency, between the SELECT statement and the subsequent 
UPDATE statement. The general assumption is that the RID will be consumed soon after 
the SELECT. Storing the RID in a permanent table is a risky design because other 
operations (e.g. REORG) could change the internal row ID.

* Scenario: Using optimistic locking in an application program
https://www.ibm.com/support/knowledgecenter/SSEPGG_11.1.0/com.ibm.db2.luw.admin.dbobj.doc/doc/r0052346.html [https://www.ibm.com/support/knowledgecenter/SSEPGG_11.1.0/com.ibm.db2.luw.admin.dbobj.doc/doc/r0052346.html]
Note that there are two flavors: RID and RID_BIT functions.

If users would really want to store the RID of the newly inserted rows through a 
trigger, if the target table has a unique key, a possible workaround is to rewrite the 
trigger to reference the base table instead of the transition table, assuming there is 
a unique key (column col1 in this example):

----
create trigger trigger_tr after insert on db2inst1.tab1
referencing new table as new_tr1 new row as new_r for each row mode db2sql
insert into db2inst1.tab2 (col1)
values ((select RID(db2inst1.tab1)
from db2inst1.tab1
where col1 = new_r.col1));
----

However, as mentioned, storing the RID in a permanent table is a risky design because 
this internal row ID could change. For a more robust design, customer is recommended 
to identify a row through and hence storing the unique key of a row, which won't 
change even when the physical layout of the table changes.

In short, it works as designed and may be called as a limitation.

Note:
This behavior might be changed without notice in the future. We can confirm whether 
this technote is valid or not by running the script.
Please contact your Sales Rep to submit a potential design change towards a future 
release. Or please open a ticket, Request For Enhancement at 
https://www.ibm.com/developerworks/rfe/ [https://www.ibm.com/developerworks/rfe/]

RELATED INFORMATION
 RID and RID_BIT scalar functions [https://www.ibm.com/support/knowledgecenter/SSEPGG_11.1.0/com.ibm.db2.luw.sql.ref.doc/doc/r0050679.html]
Scenario: Using optimistic locking in an application pr [https://www.ibm.com/support/knowledgecenter/SSEPGG_11.1.0/com.ibm.db2.luw.admin.dbobj.doc/doc/r0052346.html]