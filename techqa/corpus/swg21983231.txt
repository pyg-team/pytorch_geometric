Title: IBM PureData System for Analytics nzrestore fails for an altered table with more than 201 columns. - United States

Text:
 TECHNOTE (TROUBLESHOOTING)

PROBLEM(ABSTRACT)
 In certain releases of IBM Netezza Platform Software (see Environments for details), incremental restores could fail for tables that have more than 201 columns, and which were altered to add more columns between incremental backups. 

SYMPTOM
nzrestore (incremental) fails following error in restoresvr.log: 


Internal Error: NZ-12345/10133: *** (restoresvr) : Internal inconsistency in /production/builds/nps.rel-7.2.0.6-P1/151031-46376nps.rel-7.2.0.6-P1/main/src/bnr/bnrTable.cpp at line 406.


OR


nzrestore (incremental) fails with the following error :

Error: DB SQL 'ALTER TABLE ADMIN.MYTABLE ADD COLUMN A_NEW_COLUMN BYTEINT;' failed - DB error - ERROR: ALTER TABLE: column name "[A_NEW_COLUMN]" already exists in table '[REPRO_DB.ADMIN.MYTABLE]'.



CAUSE
When restoring incremental backups, the system applies the changes to add the columns in the first increment, but during the next incremental restore, the restore fails because it attempts to add the same new columns again. 



ENVIRONMENT
IBM Netezza Platform Software version 7.2.0.6 

IBM Netezza Platform Software version 7.2.0.6-P1 

IBM Netezza Platform Software version 7.2.0.7 

IBM Netezza Platform Software version 7.2.0.7-P1 

IBM Netezza Platform Software version 7.2.0.8 

IBM Netezza Platform Software version 7.2.1.0 

IBM Netezza Platform Software version 7.2.1.1 

IBM Netezza Platform Software version 7.2.1.1-P1 

IBM Netezza Platform Software version 7.2.1.2


DIAGNOSING THE PROBLEM
To identify whether your altered tables have encountered this column issue, you can run the following query to display a list of affected tables. 


You must run this SQL statement in each database with altered tables BEFORE doing the next differential nzbackup. If a table is flagged and has already been backed up, a restore of that prior backup will fail with the error noted above. 


select visibleid as object_id,
current_catalog as database_name,
schema as schema_name,
tablename as "Flagged Tables"

from _v_table where visibleid in ( select relid from (

SELECT attrelid relid, attorigoid origoid, COUNT(attorigoid) COUNT
FROM _t_attribute B
WHERE B.attrelid > 200000 AND attorigoid > 0
GROUP BY attrelid, attorigoid
HAVING COUNT > 1

) sub1 ) 

-----
UNION
-----

select objid as object_id,
database as database_name,
schema as schema_name,
flagged_tables as "Flagged Tables"

from
(
SELECT _v_relation_column.objid,
_v_relation_column.database,
_v_relation_column.schema,
_v_relation_column.name as flagged_tables,
sum(case when _t_object.objid = _t_object.OBJVISIBLEOID then 1 else 0 end) as column_count,
min(_t_object.objcreated) as CREATED_ON,
( select starttime
from _t_backup_history
where status = 1 and type in (0,1,2) and dbid = (select current_dbid())
order by backupset desc, seqno desc
limit 1
) as LAST_BACKUP_TIMESTAMP,
max(_t_object.objmodified) as MODIFIED_ON

FROM _v_relation_column
left outer join _t_object on _v_relation_column.objid = _t_object.objvisibleoid

WHERE -- Restrict this query to just TABLES
_v_relation_column.type = 'TABLE'

-- That have been ALTER'ed at some point in time
and _v_relation_column.attorigoid > 0

GROUP BY 1,2,3,4

HAVING column_count > 201
-- Further restrict the output to just those tables with > 201 columns
-- As only those tables exhibit this problem

AND LAST_BACKUP_TIMESTAMP BETWEEN CREATED_ON AND MODIFIED_ON
) sub2

order by 2,3,4;




RESOLVING THE PROBLEM
If the SQL query returns any affected tables you must CTAS each table, drop the old table, and rename the new table before creating a new full backup.

 



Cross reference information Segment Product Component Platform Version Edition Information Management PureData System for Analytics