Title: IBM Troubleshooting - Transaction - Resolving a Stuck Transaction - United States

Text:
 TECHNOTE (TROUBLESHOOTING)

PROBLEM(ABSTRACT)
 I think I have a stuck transaction. How can I get it to resolve? 

RESOLVING THE PROBLEM
First you must determine if you do have a "stuck" transactions that must be resolved. To do this, you will first use the tkadmin list transaction command. In all of the tkadmin commands in this example, it is assumed that the ENCINA_TK_SERVER environment variable is set to the name of the server being queried, so that the -server option can be omitted. See the documentation for more information on this environment variable if needed. 

To start:

% setenv ENCINA_TK_SERVER /.:/myEncinaCell/servers/myServer
% tkadmin list tran
8 inactive
10 inactive
40 inactive
42 inactive
50 inactive

If there are transactions in this list that are in one of the following states, and they don't seem to be changing state over time, you may have a problem. 

% tkadmin query tran

prepared
committing
commitcomplete
aborting
aborted
abortcomplete
finished

To determine if a problem exists, next figure out how long the transactions have been around. Use 

% tkadmin query tran -start

on each "interesting" transaction -- those in the states listed above. If the amount of time that has passed since the start time is large (in terms of your expected transaction times), you should evaluate if these transactions require manual intervention.

The most common reason for transactions to stay longer than expected is because some other participant in the transaction is unreachable, preventing the proper operation of the transaction system. Please check all the other participants involved in the transaction and verify that they all running and are healthy. To determine the participants in a transaction, use "tkadmin query tran" and "tkadmin query appl" on all servers that are possibly involved in the transaction.

% tkadmin query tran 8
Global identifier: 00000004011201019e25fb81e6b9d111968a9e620b8daa77
State: inactive
Originator: 01019e25fb81e6b9d111968a9e620b8daa77
Participants: 01019e25fb81e6b9d111968a9e620b8daa77 0101d61900939e83d1119c8d9e620b8daa77

% tkadmin query appl
0101d61900939e83d1119c8d9e620b8daa77

From the output above, we see that the transaction has 2 participants. We see that this server is 0101d61900939e83d1119c8d9e620b8daa77, so we still need to find the other participant (who originated the tran). 

To do this, we can perform the tkadmin query appl command on all servers that are possible participants. Or, if other participant is a recoverable server, we can use the tkadmin query process command and then ps to determine the server, as shown below:

In the cell-wide trpc directory, recoverable servers write an entry under their TRPC id, which is the same as their application id. So, you can use "tkadmin query process" to determine the pid of the server represented by a given TRPC entry, once you have an application id:

% tkadmin query process \
-server /.:/yourCell/trpc/0101d61900939e83d1119c8d9e620b8daa77
54321

and then use 'ps' to identify pid 54321.

One thing to remember is that ephemeral applications do not register with CDS and their applIds change each time they are started.

In this example, we happen to know (from our knowledge of the application) that the other participant in the transaction is a client, so querying the other servers in the cell will not locate a server with the application id of the participant of the transaction.

As the maintainer of the system, only you can tell which servers could possibly be involved in a transaction, since you are the person who best knows your application.

For demonstration purposes, pretend that transaction 8 was in the commitcomplete state and I know that my client is no longer running. So, this server is the only recoverable participant. The transaction has been running for a long time (much longer than I would expect), and I can find no reason why it hasn't resolved. I now feel that I need to intervene manually to resolve the transaction:

1) Restart the server (and if other servers were participants, I would restart those as well) to make sure that the participants in the transaction are all healthy. This restart should be a warm start -- don't erase the server. If you erase the server, you will destroy the transaction. Then, check to see if this transaction was resolved during recovery. There are transient error conditions that will prevent transaction from resolving properly. When restarting, the transactional subsystem of the server will recover the transaction and then attempt to restart the resolution process. In many cases, this is all that is necessary to resolve a "stuck" transaction.

2) After restarting the server (and all other participants), if the transaction is still stuck in the same state, I would then be confident that this transaction is not going to be resolved on its own, and take some action.

NOTE: PLEASE BE VERY CAREFUL HERE. WHEN YOU MANUALLY INTERVENE IN THE RESOLUTION OF A TRANSACTION, YOU MUST BE SURE THAT YOU UNDERSTAND THE EFFECTS OF YOUR ACTIONS. FORCING THE RESOLUTION OF A TRANSACTION CAN DESTROY THE TRANSACTIONAL INTEGRITY OF YOUR APPLICATION'S DATA. 

If you have transactions in the prepared state, they can be forced as follows:

tkadmin force tran <tid> -commit # To commit the tran

or

tkadmin force tran <tid> # To abort the tran

You have the choice of forcing either outcome, but -abort is generally safer unless you know that the other participants have committed (or will be forced to commit) the transaction. Abort is considered "safer" because once a participant forgets about a transaction (which will occur after it is "finished", including a forced finish), if another participant queries the state of that transaction, TRAN will consider it aborted (and tell the other participant that outcome) if it has no knowledge of it (thus, the "presumed abort" flavor of our two-phase commit protocol). Just remember, that it is possible that once you manually force a transaction in one direction, the Encina transactional system cannot ensure that the transaction is resolved in a consistent manner throughout all the participants. Your data may end up inconsistent, unless you are able to ensure that all participants resolve this transaction in the same way.

If transactions were forced in the previous step, or if you have transactions in the committing, aborting, commitcomplete or abortcomplete states, you can force these to finish as follows:

tkadmin force tran <tid> -finish


If transactions were forced in previous steps, or if you have transactions in the finished state, you can eliminate these by forcing a checkpoint as follows:

tkadmin force checkpoint