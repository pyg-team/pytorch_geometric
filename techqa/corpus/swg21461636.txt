Title: IBM Fixing Performance Server Out Of Memory Errors - United States

Text:
lombardi performance server data warehouse timing interval OutOfMemoryException TECHNOTE (TROUBLESHOOTING)

PROBLEM(ABSTRACT)
 The performance server JVM experiences out of memory (OOM). 

SYMPTOM
New data is not getting into the performance server and the performance server is failing without memory errors.


CAUSE
One likely cause is because either specific or autotracked timing intervals are present in a long running or looping business process definition (BPD).

DIAGNOSING THE PROBLEM
Run the following SQL command on your performance sever schema to validate the error is related to tracking data: 

 * 
 * MS-SQL:
   select top 100 FUNCTIONAL_TASK_ID, count(*)
   total
   from LSW_TRACKING_POINT_VALUE
   group by FUNCTIONAL_TASK_ID
   order by total desc

 * Oracle:
   select * from (select FUNCTIONAL_TASK_ID, count(*)
   as total
   from LSW_TRACKING_POINT_VALUE
   group by FUNCTIONAL_TASK_ID
   order by total desc)
   where rownum < 100
 * 
 * 
 * DB2:
 * 
 * select
 * * 
 * from
 * (
 * select
 * FUNCTIONAL_TASK_ID, 
 * count
 * (*)
 * 
 * as
 * total
 * 
 * from
 * LSW_TRACKING_POINT_VALUE
 * 
 * group
 * 
 * by
 * FUNCTIONAL_TASK_ID
 * 
 * order
 * 
 * by
 * total 
 * desc
 * ) 
 * 
 * FETCH
 * 
 * FIRST
 * 100 
 * ROWS
 * 
 * ONLY
 * 
   
 * 
 * FUNCTIONAL_TASK_ID TOTAL
   2678 17200
   2721 16573


Totals over 10,000 confirm the problem. You can resolve this issue quickly. 
RESOLVING THE PROBLEM
You need to delete the timing intervals for all the totals that are over 10,000. 


The following query in the performance server schema gives you the BPD instance ID's that are involved in the loops. For your in clause, use the FUNCTIONAL_TASK_ID's from the previous query.


 * select distinct (SYSTEM_FUNCTIONAL_TASK_ID) as bpd_instance_id
 * 
 * from LSW_TASK where FUNCTIONAL_TASK_ID in (2678, 2721)


When you run the previous query if you do not get back integers (for instance you get back something that starts with "x"), then the problems are not from BPDs. 

In this example, the result BPD instance IDs are 1 and 2. If you want to dig deeper into where your loop is you can use the BPD_NAME and ACTIVITY_NAME columns of LSW_TASK to find out which BPDs and activities are involved. The BPD_NAME is useful as it gives you the name of the sub BPDs that might be involved. This approach is useful as you can hand this data to your developers so they can fix the loop and prevent this problem in the future. 

If you have determined that you can go without this data , which you probably can because it is very likely from an unplanned loop, it is now time to delete the bad data. Stop the performance servers and backup the performance server schema. 
Note: Your users will not be affected as the performance server can be stopped and BPD and service execution will continue uninterrupted. 

In the previous example, there are two functional task IDs. Before we delete these tracking points, first delete the rows in TW_PROCESSFLOWS, a table that is used for autotracking. If the looping is from declared tracking points, the rows will not have any values. See the following command: 
 * delete from TG_PROCESSFLOWS where 
 * FUNCTIONAL_TASK_ID
 * in (2687,2721)


You can then try the following main delete command: 
delete from LSW_TRACKING_POINT_VALUE where functional_task_id in (2687,2721) 

It is VERY likely that this command will fail with a constraint violation. This failure is expected as you will need to delete the rows from the TG_* tables that use these bad values. For instance when running the above SQL, the following error is generated: 

integrity constraint (622JBOSSPERF.TG_AT129062015_FK0) violated - child record found 

This issue is solved by running the following delete commands. Note: Your tables will be different.  * delete from TG_AT1290620159019 where 
 * FUNCTIONAL_TASK_ID
 * in (2687,2721)
 * 
 * delete from TG_AT1290620170688 where 
 * FUNCTIONAL_TASK_ID
 * in (2687,2721)


The following main delete command should work:  * delete from LSW_TRACKING_POINT_VALUE where functional_task_id in (2687,2721)


Executing the correct SQL and table definitions might be tricky as there might be many TG tables that are affected. It is recommended that you involve your database administrator to follow the constraints and delete the data from the child tables. 

Restart the performance server and it should continue without running out of memory.  


Cross reference information Segment Product Component Platform Version Edition Business Integration IBM Business Process Manager Express Performance Data Warehouse Linux, Linux zSeries, Windows 8.5.5, 8.5.0.1, 8.5, 8.0.1.3, 8.0.1.2, 8.0.1.1, 8.0.1, 8.0, 7.5.1.2, 7.5.1.1, 7.5.1, 7.5.0.1, 7.5 Not Applicable Business Integration IBM Business Process Manager Advanced Performance Data Warehouse AIX, Linux, Linux zSeries, Solaris, Windows, z/OS 8.5.5, 8.5.0.1, 8.5, 8.0.1.3, 8.0.1.2, 8.0.1.1, 8.0.1, 8.0, 7.5.1.2, 7.5.1.1, 7.5.1, 7.5.0.1, 7.5 Not Applicable Business Integration IBM Business Process Manager Standard Performance Data Warehouse AIX, Linux, Linux zSeries, Solaris, Windows 8.5.5, 8.5.0.1, 8.5, 8.0.1.3, 8.0.1.2, 8.0.1.1, 8.0.1, 8.0, 7.5.1.2, 7.5.1.1, 7.5.1, 7.5.0.1, 7.5 Not Applicable Business Integration WebSphere Lombardi Edition Performance Data Warehouse AIX, HP-UX, Linux, Linux zSeries, Linux/x86, Solaris, Windows, Windows Vista, Windows XP 7.2.0.5, 7.2.0.4, 7.2.0.3, 7.2.0.2, 7.2.0.1, 7.2 All Editions