Title: IBM Object scope inside SQL routine has changed after migrating to v9.7 - United States

Text:
 TECHNOTE (FAQ)

QUESTION
 After migrating to DB2 v9.7 or higher why does my v9.1/v9.5 SQL routine (stored procedure / user defined function) return SQL0204N (-204) ? 

CAUSE
 

The scope of an object inside a SQL routine (stored procedure / user defined function) in DB2 v9.7 is different from previous releases. 

The SQL0240 typically appears when trying to create or call a routine that creates a table before using it. Since this table does not exist before calling the routine DB2 will return SQL0204

These symptoms are related to the new automatic revalidation feature introduced in DB2 v9.7. On v9.1/v9.5 DB2 invalidates the package associated with the stored procedure, but on v9.7 DB2 invalidates both the package and the stored procedure. When the stored procedure is invalidated under the covers DB2 will try to revalidate it but fails because it is unable to find a dependant object. 

.


ANSWER
 

CREATE PROCEDURE sp_ctab()
RESULT SETS 0
LANGUAGE SQL
P1: BEGIN 
create table db2inst1.t1(c1 integer);
commit;
END P1 % 

CREATE PROCEDURE sp_insert()
RESULT SETS 0
LANGUAGE SQL
P1: BEGIN 
call sp_ctab();
insert into db2inst1.t1 values(12);
commit;
END P1 % 


With older releases the example below would have succeeded because sp_insert() calls sp_ctab() to create the table db2inst1.t1 before inserting into it. 

 

db2 "drop table db2inst1.t1"
DB20000I The SQL command completed successfully. 

 

db2 "call sp_insert()"
DB20000I The SQL command completed successfully.


However beginning with DB2 v9.7 it would fail with SQL0204N ( SQL0204N "<name>" is an undefined name) 

 

db2 "drop table db2inst1.t1"
DB20000I The SQL command completed successfully.

db2 "call sp_insert()"
SQL0727N An error occurred during implicit system action type "1".
Information returned for the error includes SQLCODE "-204", SQLSTATE "42704"and message tokens "DB2INST.T1". SQLSTATE=56098 




Workaround #1: Create a dummy definition of the table

CREATE PROCEDURE sp_ctab()
RESULT SETS 0
LANGUAGE SQL
P1: BEGIN
create table db2inst1.t1(c1 integer);
commit;
END P1 % 

CREATE PROCEDURE sp_insert()
RESULT SETS 0
LANGUAGE SQL
P1: BEGIN

-- Add dummy definition here that matches table DDL in sp_ctab()
if 1=0 then
create table db2inst1.t1(c1 integer);
end if;

call sp_ctab();

insert into db2inst1.t1 values(12);
commit;
END P1 % 





Workaround #2: Substitute a Created Temporary Table

This example assumes that the legacy routine was using a Declared Global Temporary Table.

-- Create bufferpool and user temporary tablespace needed for the DGTT and CTT

create bufferpool temppool immediate pagesize 4k %

create user temporary tablespace temptb pagesize 4k managed by automatic storage %

create procedure init_dgtt() 
begin 
declare global temporary table SESSION.dep_tmp (x int) with replace;
truncate table session.dep_tmp immediate;

end %

create procedure test() 
begin 

call init_dgtt();
insert into session.dep_temp values(123); 
end %


We replace the DGTT with a CTT.


create global temporary table CGTT1(C1 integer)
on commit preserve rows
not logged on rollback preserve rows
in temptb %

create procedure init_ctt()
begin

truncate table CGTT1 immediate;
commit;
end %

create procedure test()
specific sp_test
begin
declare N integer;

call init_ctt();

insert into CGTT1 values (123);

end %





RELATED INFORMATION
 Automatic revalidation of database objects [http://publib.boulder.ibm.com/infocenter/db2luw/v9r7/topic/com.ibm.db2.luw.admin.dbobj.doc/doc/c0055269.html]
Soft invalidation and automatic revalidation support ad [http://publib.boulder.ibm.com/infocenter/db2luw/v9r7/topic/com.ibm.db2.luw.wn.doc/doc/c0053725.html]
Creating and connecting to created temporary tables [http://publib.boulder.ibm.com/infocenter/db2luw/v9r7/topic/com.ibm.db2.luw.admin.dbobj.doc/doc/t0054147.html?]
Declaring Temporary Tables [http://publib.boulder.ibm.com/infocenter/db2luw/v9r7/topic/com.ibm.db2.luw.admin.dbobj.doc/doc/t0020127.html]