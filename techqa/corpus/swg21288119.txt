Title: IBM A REFRESH of a MQT table causes queries against SYSCAT.TABLES and SYSIBM.SYSTABLES catalog tables to hang in LOCK-WAIT state - United States

Text:
 TECHNOTE (FAQ)

QUESTION
 When a REFRESH TABLE is being executed against a DB2 MQT table, other users executing queries against SYSCAT.TABLES or SYSIBM.SYSTABLES experience lock-waits and/or lock time-outs. 

ANSWER

CAUSE

Refresh MQT acquires exclusive locks on the catalog tables SYSIBM.SYSTABLES - this is expected functionality. When a refresh is going on, an IX lock is acquired on SYSIBM.SYSTABLES and an X lock is acquired on row level, so any application asking for locks has to wait until the REFRESH is done. 

During a REFRESH, there is some information that needs to be stored/updated in catalog (hence X lock on catalog row). In v8, the catalog update is done up-front (i.e. during compilation time, and hence for the duration of the REFRESH TABLE execution, the lock is held)

Database snapshots can be used to verify the state of the agents that are hung in lock-wait state - including their catalog queries. Users that experience LOCK TIMEOUTS will receive an error message that their query failed.

SCOPE



Product Name Product Version(s) Hardware Vendor Operating System DB2 Universal Database (UDB®) for Linux-Unix and Windows  * Version 7.1 
 * Version 7.2

All All DB2 Universal Database (UDB®) for Linux-Unix and Windows  * Version 8.1 
 * Version 8.2

All All 
SOLUTION Try to resolve the error using any of the methods below: 

 * Upgrade to DB2 UDB V9. A design change has been done in v9 to move the catalog update to run-time, after the REFRESH TABLE execution. This will help alleviate this problem. 
 * If a FULL refresh is being executed, try using a REFRESH INCREMENTAL instead. 
 * If practical, change the isolation level or the catalog queries to Uncommitted Read (UR). 
 * Tune all or some of these database configuration parameters to help alleviate lock-waits -  1. Log buffer size (4KB) (LOGBUFSZ) 
    2. Database heap (4KB) (DBHEAP) 
    3. Number of asynchronous page cleaners (NUM_IOCLEANERS) 
    4. Number of I/O servers (NUM_IOSERVERS) 
    5. CATALOGCACHE_SZ
   
   
 * Create a bigger buffer pool to fit the dimension in memory (or mostly in memory) to minimize the locking issue. 
 * If users are doing a full refresh (i.e. refresh of a deferred MQT without staging table, or certain mode of refresh for immediate MQT), and it is NOT a replicated MQT, a potential work-around would be:
   1. declare cursor for <MQT definition subquery>
   2. load from cursor replace into <MQT>
   3. set integrity for <MQT> immediate unchecked