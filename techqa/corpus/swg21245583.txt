Title: IBM Rational Rose: Public Java class changes to type Implementation when Reverse Engineering - United States

Text:
Java; reverse engineering; public; change; implementation; structure; model; source code; physical structure; directory; Rose Professional J Edition; repackage; reverse engineering Java components; modeling .java files; 1245583 TECHNOTE (TROUBLESHOOTING)

PROBLEM(ABSTRACT)
 You have two public Java™ classes A and B in the same package, and class A contains a type of class B (Note: when reverse engineering class A, class B will also be reverse engineered because class A declares a type of class B). When class A is reverse engineered into a package structure in the model which differs from the package specification inside of the Java source file, the public declaration for class B is changed to implementation. 

CAUSE
When forward or reverse engineering Java code, IBM® Rational Rose® relies on components to model the physical Java file and directory structure. If the Logical View or Component View package structures do not match the physical structure of the Java source files, this reverse engineering issue will arise.

RESOLVING THE PROBLEM
At first glance, this situation may be viewed as a defect since Rose is changing the public declaration of class B to implementation. This is not the case, however. This is a situation where Rational Rose is working as designed. The declaration of the class is changed to implementation because Rose relies on the structure of the model matching up with the physical structure of the Java source code. However, when these structures do not match, Rose is designed to encompass the classes inside of the package specified in the Java source code, which is why the class is changed to type implementation.


Below are excerpts from the Rose Help Contents which explain the way Rose expects the model to be structured when dealing with Java source files. 


In a literal sense, Rose for Java will model *.java files as Rose components in your model’s Component View: 


[/support/docview.wss?uid=swg21245583&amp;aid=1]
For practical purposes, though, this component and its identically named Java class will be an inseparable set.

In Rose, components and component diagrams represent the physical (versus the logical) structure of your model. Hence, in code generation and reverse engineering, Rose relies on components to model the physical Java file and directory structure.

Note: In the illustration above, components are usually part of component packages, which are the Rose Java way of modeling Java packages.


[/support/docview.wss?uid=swg21245583&amp;aid=2]

When you reverse engineer Java source, Rose Java creates the Java components for you. For example, if you reverse engineer a .java file that defines 10 classes, Rose creates a component using the .java file name. All 10 classes in the model are assigned to that component. 

If your .java file contains import statements for other .java files, Rose creates a dependency relationship between them. For example, if you reverse engineer a class called Fruit that extends the Java applet class, Rose creates a dependency between Fruit and the applet class.

Note: When Rose for Java models components and component packages from your Java source, it creates a mirror images of the component structure in your Logical View using the logical component packages and logical components. For example, the source element:

package Birds. Raptors;

generates this structure in your model:

[/support/docview.wss?uid=swg21245583&aid=3] [/support/docview.wss?uid=swg21245583&aid=3]

This information above confirms that when dealing with generating code and reverse engineering of Java files, it is vital that the package structure in the Logical and Component view matches up with the physical Java file and directory structure.