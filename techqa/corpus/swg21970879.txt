Title: IBM LOB Space Allocation and Management - United States

Text:
 TECHNOTE (FAQ)

QUESTION
 How does DB2 perform LOB Space Allocation and Management 

ANSWER
DB2 stores most row data in fixed size (4KB, 8KB, 16KB, 32KB) pages. This data is referenced by queries via bufferpool access, i.e. it is read from disk into bufferpool memory to be worked on.
LOB (large object) data is handled differently. A LOB (CLOB - character large object, BLOB – binary large object, or DBCLOB - double byte large object) is stored outside regular row based storage. A LOB can be up to 2GB in size (1GB for a logged LOB). The necessity of handling large amounts of data of potentially very disparate sizes efficiently is what drives the LOB storage mechanism. 

 

There is a descriptor in the regular row data that points to the actual LOB data itself. The size of this descriptor varies from 60 to 312 bytes, depending on the size defined for the LOB in the definition of the table. The actual size of the LOB data is also included in the descriptor. If a row's LOB is defined with an inline size, then, if the entire LOB will fit, it will be inlined into the regular data page. If the LOB data is larger than the inline size, none of the LOB will be inlined. If the actual LOB size is smaller than the descriptor size, it will be implicitly inlined, even if no inlining is defined in the table definition. 

All LOB data that does not get inlined as described above will be stored as follows. 

LOB data has two components, LBA and LB. The LBA object contains all space allocation information. The LB object contains the actual LOB data. If the tablespace is defined as using System Managed Storage (SMS), then these two objects can be seen as separate files, with .LBA and .LB file extensions. Data in the LBA object passes through the bufferpool. Data in the LB object is not buffered by DB2. Some memory buffering of LB data can be obtained by utilizing the OS file system cache. 

The LOB space storage uses what is called a Buddy Space mechanism. There are two types of buddy space - Super Buddy Space (SBS) and Regular Buddy Space (RBS). SBSes control allocation of large segments of data, from 256k to 64m bytes. An RBS controls allocation of segments of size 1k (the minimum LOB allocation unit) to 128KB. There are multiple RBSes per SBS. 

In an empty table, there is just one SBS. We then insert a 50KB LOB. As the LOB is inserted, the SBS gets subdivided (always by a factor of 2) until, eventually, we have an RBS segment of a size that can completely contain the LOB, i.e. the RBS size will be 64K. Since we always subdivide by factors of 2, at this stage we will have the occupied segment, and a free buddy segment of 64k, as well as free buddy segments back up the chain at the 128KB (RBS), 256KB(SBS), 512KB(SBS) size, and so on. DB2 maintains a hint of where space of a particular size is located, and so another insert of, say, 60KB, would go straight to the buddy segment of the first insert. If we do a third insert (55KB this time), we have no pointer to free space of the right size, so we will look for a segment of the next largest size, i.e. 128KB, and we will subdivide that into 2 64KB segments, and use one of them. The other (its buddy) will be free space. 

The space remaining in a segment beyond the user data is not used, i.e. for our first insert of 50KB, the last 14KB is not used. There is a COMPACT option which can be specified for LOB columns. The effect of specifying this option is to subdivide the LOB data into smaller pieces to derive a closer 'fit' with the buddy segment sizes. For example, for our first insert of 50KB of data, with COMPACT we would divide data into a 32KB, 16KB and 2KB segment, and would thereby not 'waste' any space at all. However, these pieces will not necessarily be contiguous and may even be widely separated, and so retrieval of the data may suffer. Update operations are also affected by COMPACT. Generally with LOBs, an update will result in a delete followed by an insert. This will always be the case when COMPACT is specified. However, in the case of our first 50KB LOB insert, a subsequent operation that appended, say, 12KB of data would result in an in-place update of the existing segment, and result in less 'waste' at the end of the segment. Use of COMPACT is not recommended in most scenarios. 

A delete of a LOB will put its buddy space into a delete-pending state. After commit takes place the segment is eligible to move to a free state. If the buddy space of the freed segment is also free, the two will be combined to form a single segment of the next higher size, for example two 64KB buddy spaces would become a 128KB buddy. 

As already mentioned, DB2 maintains hints of where the next piece of space of a particular size is located. These hints can be maintained by both insert and delete operations. They will also indicate when there is no free space, i.e. a new insert needs to extend the tablespace. This hinting mechanism is however just a single indication. If we assume a situation where some delete jobs have created some free buddy space segments of various sizes in the “middle” of the table, the hints will be pointing to this newly freed area. When multiple concurrent inserts try to use this space, only one will get it. The other inserts will have to search for free space. The space search could be very lengthy – the next free buddy space segment of the right size could be a long way away. Also, when there are concurrent inserters in this state, referencing the allocation pages themselves could suffer from contention issues. Once new free space is found, the hint mechanism will be reestablished, with the likely result that inserts will become quick once again. This kind of situation can lead to erratic insert times – normally quick, but occasionally long, or even very long. 

Advice is to :
- Inline the LOBs if possible.
- Increase the bufferpool to a FIXED size so space management pages can be
kept in the bufferpool to avoid physical IO to disk in order to have them in the bufferpool.
- Make sure that Operating System Filesystem Cache is enabled for LOBs Tablespaces.
- REORG using LONGLOBDATA, or use admin_move_table, or copy to another table with LOAD from Cursor and then rename.

Some further details relating to LOB Objects:

- An update of a LOB is mostly a delete/insert of a LOB.
- LOB Allocation Pages(LOBA) are read into the bufferpool assigned to the LONG part of the table.
- APPEND ON does not work for LOBs, it only works for REGULAR data.
- DB2MAXFSCRSEARCH can only be used for REGULAR data to limit
the number of space management pages DB2 reads before appending data at the end of the table. It does not work for LOBs. There is no 'exit procedure' in the insert LOB algorithm.
- There are no stats available on how deorganized/fragmented a LOB table
is. No reorgchck for LOBs either. db2 inspect does give some indication
on the number of space management pages.

The insert LOB algorithm tries to accommodate LOBS of any size.

This means the number of space management pages to be read in order to find free space depends on :
- The size of the LOB to be inserted. The larger the LOB the more space management pages need to be read in bufferpool memory.
- How unorganised the table is due to lots of deletes and updates that have been one on the table. The more unorganised the more pages need to be read in order to find free space.