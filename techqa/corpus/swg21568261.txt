Title: IBM Improving Spatial Query Performance - United States

Text:
Slow Spatial Query TECHNOTE (FAQ)

QUESTION
 How do you improve spatial query performance in IBM DB2 Spatial Extender for AIX , Linux- UNIX and Windows? 

CAUSE
The query in question is: 
select long,lat from GEOUW.spatial_test a where 
db2gse.ST_Distance(db2gse.st_point(long, lat, 1), db2gse.ST_Point( 11.61443 , 48.13175, 1 ),'KILOMETER') <1;

The primary factor for poor performance is the lack of index exploitation in the query. The consequence is that the linear distance needs to be calculated between the candidate location, db2gse.ST_Point( 11.61443 , 48.13175, 1 ), and every point in the table. This is a complex calculation involving several trigonomic functions. As the size of the table increases, the query time may increase linearly with the size of the table.

A second factor is that a spatial point value is being constructed from the latitude and longitude for each row in the table being scanned during the query. This is not exceptionally complex, but does take some time.


ANSWER
The typical solution to this problem is to store the spatial value in a column in the table, create a spatial index on this column and ensure that the spatial index is exploited. 

For example: 

 1. add a column with the name 'point' with type db2gse.st_point 
 2. alter the table with 'activate not logged initially' in the same UOW as the update statement. if the table is very large, log space can be an issue. 
 3. update the table, setting the point value from the latitude and longitude. The srid value '1' is used which is for NAD83 coordinate, more applicable to North America. It may be better to use an srid value of '1003' for WGS84, more applicable for world-wide coordinates. 
 4. create a spatial index on the point column with a grid size of 0.1 decimal degrees which corresponds to about 11km 
 5. update table statistics


Here is the sample sql for the above recommendations: alter table GEOUW.spatial_test add column point db2gse.st_point; 

commit work; 

alter table GEOUW.spatial_test activate not logged initially; 

update GEOUW.spatial_test 

set point = db2gse.st_point(long, lat, 1); 

commit work; 

create index GEOUW.spatial_test_idx on GEOUW.spatial_test(point) extend using db2gse.spatial_index(0.1,0,0); 

commit work; 

runstats on table geouw.spatial_test and indexes all; 

COMMIT WORK; 

The query then becomes: 

select id, long,lat 

from GEOUW.spatial_test a 

where db2gse.ST_Distance(point, db2gse.ST_Point( 11.61443 , 48.13175, 1 ),'KILOMETER') <1 

Unfortunately, it is not possible for DB2 to exploit the spatial index with ST_Distance in the predicate when the coordinates are in decimal degrees and a linear unit such as 'KILOMETER' is specified. This is a very common situation and the approach to address this is to include an additional clause in the query which can exploit the spatial index by approximating the distance in decimal degrees. The following is an example: 

select id, long,lat 

from GEOUW.spatial_test a 

where db2gse.ST_Distance(point, db2gse.ST_Point( 11.61443 , 48.13175, 1 ),'KILOMETER') <1 

and db2gse.ST_Distance(point, db2gse.ST_Point( 11.61443 , 48.13175, 1 )) < 0.1 selectivity 0.0001 

The value '0.1' in the second predicate clause is 0.1 decimal degrees which is approximately 11km, larger than the desired distance range of 1.0km. A smaller value could be used although it may not significantly improve performance. The clause 'selectivity 0.0001' informs the DB2 optimizer that this predicate has a high degree of selectivity and index exploitation will be helpful. 

It is always good to check that the access plan generated by DB2 for the query references the spatial index. This can be checked with various visual explain or other tools.