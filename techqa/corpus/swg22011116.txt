Title: IBM Calling Secure FCI REST Services from IIB Flows - United StatesSubflow details

Text:
 TECHNOTE (TROUBLESHOOTING)

PROBLEM(ABSTRACT)
 You can configure a message flow to ensure secure connections. This process includes configuration for the message broker and developing the message flow. FCI exposes several APIs through secured REST services. 

DIAGNOSING THE PROBLEM
 After a standard installation of IBM Integration Bus (IIB), the brokers cannot access secured services. You can configure the message broker to make secure connections, and then invoke the secured services from a message flow.

RESOLVING THE PROBLEM
 

You can configure a message flow to ensure secure connections. This process includes configuration for the message broker and developing the message flow.

ICFM exposes several APIs through secured REST services. After a standard installation of IBM® Integration Bus (IIB), the brokers cannot access secured services. You can configure the message broker to make secure connections, and then invoke the secured services from a message flow. 


CONFIGURING THE MESSAGE BROKER
Message brokers do not come with certificates to enable SSL communication. To enable secure messages, you must configure this SSL connection.

To enable the message broker to perform the appropriate SSL handshake with ICFM, you must create a keystore and truststore. You must also create a certificate for the message broker, and the WebSphere® Application Server certificate must be imported into the truststore. The message broker must be configured to know about the truststore or keystore files. Finally, the broker must be configured with the password that is used to access the truststore or keystore. The following steps also enable the message broker to receive both HTTP and HTTPS requests by using the HTTP Input node, though this configuration is not required to make calls to the REST services.

PROCEDURE
To configure the message broker:

 1. In the IBM® Integration Console, run the following commands to configure the broker: export BROKER_NAME="CFQM.BR"
    export PASSWD="CounterFraud1"
    export BASE_LOC="/var/mqsi/components/${BROKER_NAME}/"
    export BROKERFILE_PREFIX="${BASE_LOC}/$BROKER_NAME"
    export BROKER_HTTPS_PORT=7094
    export BROKER_HTTP_PORT=7091
    
    
 2. Ensure that the broker is running: mqsistart $BROKER_NAME
    
    
 3. Run the following commands to create the keystore, truststore, or self-signed certificate: runmqckm -keydb -create -db ${BROKERFILE_PREFIX}keystore.jks -pw $PASSWD -type jks
    runmqckm -keydb -create -db ${BROKERFILE_PREFIX}truststore.jks -pw $PASSWD -type jks
    runmqckm -cert -create -db ${BROKERFILE_PREFIX}keystore.jks -pw $PASSWD -label ${BROKER_NAME}Cert -dn "CN=${BROKER_NAME}.server,O=IBM,OU=ESB,L=RTP,C=US"
    runmqckm -cert -extract -db ${BROKERFILE_PREFIX}keystore.jks -pw $PASSWD -label ${BROKER_NAME}Cert -target ${BROKERFILE_PREFIX}Cert.arm -format ascii
    runmqckm -cert -add -db ${BROKERFILE_PREFIX}truststore.jks -pw $PASSWD -label ${BROKER_NAME}Cert -file ${BROKERFILE_PREFIX}Cert.arm -format ascii
    
    
 4. Import the WebSphere Application Server certificate for ICFM:  1. Use your browser tools to locate your certificates. For Firefox browsers, the menu path is Tools > Options > Advanced > Certificates > View Certificates > Servers > IBM > your_certificate.
     2. Export the certificate to a base location.
     3. Use the following command to add the certificate: runmqckm -cert -add -db ${BROKERFILE_PREFIX}truststore.jks -pw $PASSWD -label ${BROKER_NAME}CFMIIBREST -file ${BASE_LOC}/your_certificate.crt -format ascii
        
        
    
    
 5. Use the following commands to register the keystore or truststore with the broker: mqsichangeproperties ${BROKER_NAME} -o BrokerRegistry -n brokerKeystoreFile -v ${BROKERFILE_PREFIX}keystore.jks
    mqsichangeproperties ${BROKER_NAME} -o BrokerRegistry -n brokerTruststoreFile -v ${BROKERFILE_PREFIX}truststore.jks
    
    
 6. Stop the broker: mqsistop ${BROKER_NAME}
    
    
 7. Configure the passwords: mqsisetdbparms ${BROKER_NAME} -n brokerKeystore::password -u ignore -p $PASSWD
    mqsisetdbparms ${BROKER_NAME} -n brokerTruststore::password -u ignore -p $PASSWD
    
    
 8. Restart the broker manager and broker: su mqbrkr
    mqsistart $BROKER_NAME
    
    

DEVELOPING THE MESSAGE SUBFLOW
You use a message subflow to invoke the secured services from your message flow. After you develop the subflow, you add the subflow to the main flow. 

The message to the subflow must be of type GetPartyIDRequest, which specifies the name for which ICFM must be queried. The user-defined properties must specify the configuration for the environment in which the subflow is run:  * counterFraudServicesBaseURL
 * restServiceUser
 * restServicePassword

Alternatively, the authentication details for invoking ICFM REST service can be defined in the SecurityProfiles configurable service so that the user name and password are not provided in clear text.

Subflow details SUBFLOW DETAILS
For this example, a subflow that is called GetPartyID is created. The subflow invokes ICFM to search for parties that match a name that is provided by the invoking flow. 

The following three parameters generally do not change for an installation:  * The base URL that is used to access the Counter Fraud Services API
 * The user name that is authorized to access the REST services
 * The password for the user name

These three values are configured as User-Defined Properties on the subflow. All three properties are of type String and are required parameters.

The following sections provide more details for the other flows.

INPUT
Tab Property Value Description Node Name Input HTTP HEADER
Tab Property Value Description Node Name HTTP Header HTTPInput HTTPInput Header Options Delete Header HTTPResponse HTTPResponse Header Options Delete Header HTTPRequest HTTPRequest Header Options Add Header HTTPReply HTTPReploy Header Options Delete Header PREPAREPARTYLOOKUPREQUEST
Tab Property Value Description Node Name preparePartyLookupRequest Basic ESQL Module GetPartyID_preparePartyLookupRequest Content that is related to the ESQL Module: DECLARE restServiceUser EXTERNAL CHARACTER 'p8admin';
DECLARE restServicePassword EXTERNAL CHARACTER 'password';
DECLARE counterFraudServicesBaseURL EXTERNAL CHARACTER 
'https://cfhost.ibm.com:9702/CounterFraud_SVC';
	CREATE COMPUTE MODULE GetPartyID_preparePartyLookupRequest
	CREATE FUNCTION Main() RETURNS BOOLEAN
		BEGIN
			DECLARE partyName CHARACTER;
			CALL CopyEntireMessage();
			SET partyName = OutputRoot.DFDL.GetPartyIDRequest.body.body_elem1; 
			SET OutputRoot.HTTPRequestHeader."Authorization" = 
'Basic '||BASE64ENCODE(CAST(restServiceUser || ':' || 
restServicePassword as BLOB CCSID InputRoot.Properties.CodedCharSetId));
			SET OutputRoot.HTTPRequestHeader."X-Original-HTTP-URL" = 
counterFraudServicesBaseURL || '/jaxrs/fact/search?name=' || 
urlEncode(partyName) || '&type=party';  			
			RETURN TRUE; 	
		END;  	
		CREATE FUNCTION urlEncode(IN toEncode CHAR) 		
		RETURNS CHAR 	
		LANGUAGE JAVA  	
		EXTERNAL NAME "com.ibm.iuc.common.HTTP.urlEncode";   	
		CREATE PROCEDURE CopyEntireMessage() BEGIN 		
			SET OutputRoot = InputRoot; 	
		END; 
END MODULE;

HTTP REQUEST
Tab Property Value Description Node Name HTTP Request Basic Web service URL http://www.ibm.com/ [http://www.ibm.com/] HTTP Settings HTTP Method POST SSL Protocol SSL SSL SSL client authentication key alias Cfm-was Response Message Parsing Message Domain JSON Although the basic tab requires the Web service URL to be set, this value is overridden by the GetPartyID_preparePartyLookupRequest compute node.

HTTPREQUESTFAILURE
Tab Property Value Description Node Name HTTPRequestFailure Basic Destination File Basic Filepath C:\temp\GetPartyID.log Basic Pattern See following example. The following example provides all of the pattern detail that is available: **************************
**  HTTPRequestFailure  **
**************************
<<<  ${EXTRACT(HOUR FROM CURRENT_TIMESTAMP)}:${EXTRACT(MINUTE FROM CURRENT_TIMESTAMP)} >>>
Root:
${Root}
--------------------------------------------------------------------------------
Environment:
${Environment}
--------------------------------------------------------------------------------
LocalEnvironment:
${LocalEnvironment}
--------------------------------------------------------------------------------
ExceptionList:
${ExceptionList}
==================================================

PREPAREPARTYLOOKUPRESPONSE
Tab Property Value Description Node Name preparePartyLookupResponse Basic ESQL Module GetPartyID_preparePartyLookupResponse Content that is related to the ESQL Module: CREATE COMPUTE MODULE GetPartyID_preparePartyLookupResponse
	CREATE FUNCTION Main() RETURNS BOOLEAN
	BEGIN
		CALL CopyNonHTTPMessageHeaders();
		SET OutputRoot.Properties.MessageType = '{}:GetPartyIDResponse';
		CREATE FIELD OutputRoot.DFDL.GetPartyIDResponse.body;
		DECLARE InputPointer REFERENCE TO InputRoot.JSON.Data.results;
		DECLARE OutputPointer REFERENCE TO OutputRoot.DFDL.GetPartyIDResponse.body;
		MOVE InputPointer FIRSTCHILD; --- now the pointer points to first item element Item[1]
		WHILE LASTMOVE(InputPointer) DO
			CREATE FIRSTCHILD OF OutputPointer  NAME 'partyId' VALUE InputPointer.id;
			MOVE InputPointer NEXTSIBLING;
		END WHILE;
		RETURN TRUE;
	END;
	CREATE PROCEDURE CopyNonHTTPMessageHeaders() BEGIN
		DECLARE H INTEGER 1;
		DECLARE I INTEGER 1;
		DECLARE J INTEGER;
		SET J = CARDINALITY(InputRoot.*[]);
		WHILE I < J DO
			IF NOT CONTAINS(InputRoot.*[I], 'HTTP') THEN
				SET OutputRoot.*[H] = InputRoot.*[I];
				SET H = H + 1;
			END IF;
			SET I = I + 1;
		END WHILE;
	END;
END MODULE;

OUTPUT
Tab Property Value Description Node Name Output