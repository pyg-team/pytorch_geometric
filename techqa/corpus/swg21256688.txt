Title: IBM Memory problems can occur when using large business objects for WebSphere Process Server (WPS) and WebSphere Enterprise Service Bus (WESB) - United States

Text:
OutOfMemory error; outofmem; memory; memory leaks; leaks TECHNOTE (TROUBLESHOOTING)

PROBLEM(ABSTRACT)
 The use of large business objects in WebSphere Process Server or WebSphere Enterprise Service Bus can cause memory-related problems for the application server process. 

SYMPTOM
The problems occur when the sizes of business objects reach capacity limits, and include these problems with the Java™ heap. You might see: 

 * Out of memory exceptions 
 * Memory leaks


CAUSE
The problems that occur are directly related to the size and complexity of business objects. There are two main problems that can occur:


Out of memory exceptions

ByteArrayOutputStream is used to serialize the object. Each serialization results in requests for large allocations of contiguous space in the Java virtual machine (JVM) heap. When the heap cannot satisfy the request for a block of contiguous space, the JVM generates an OutOfMemory exception. The memory allocation algorithm implemented by ByteArrayOutputStream might allocate contiguous buffer space up to twice the size of the object.

OutOfMemory exceptions can occur at a variety of different points during processing. For example, OutOfMemory exceptions can occur when objects are being copied, serialized, or deserialized, and so forth. For large business objects, these points can occur during JMS processing (including transaction commit), during SCA asynchronous operations, browsing queues for large JMS messages from the administrative console, and so forth.  * memory leaks 
   
   As the heap is stressed, garbage collection statistics can reveal symptoms similar to a memory leak. Typically, problems do not occur for business objects of nominal size (XML files of 20 MB or less). As the size of business objects grows, the amount of free space in the heap is reduced in a nonlinear manner. This situation is caused by 'spurious object references' that can occur when objects in the heap are moved around during heap compaction for garbage collection cycles. Spurious object references are usually harmless when the objects 'referenced' are small in size. However, in the case of large and complex business objects, a spurious reference to a single object within the business object structure can result in many interconnected objects being in memory. The reference to the object within the structure prevents the garbage collector from reclaiming the heap space for the entire business object structure.

RESOLVING THE PROBLEM
It is important to note that the size of a business object XML file does not correlate to the amount of heap space that is required. This difference is because various operations performed by WebSphere Process Server to support the features of business objects require memory expansions, which means significantly more heap than indicated by the original size of the business object. The operations performed also vary according to the model. For example, the Service Component Architecture (SCA) asynchronous model requires far more heap resources to serialize and deserialize objects; those operations are not necessary under the SCA synchronous model. 

For applications that have requirements for processing large business objects, consider the following solutions: 


OutOfMemory exceptions


 * Be aware that the SCA asynchronous model requires more heap resources than the SCA synchronous model. 
   
 * When using JMS bindings, the retry count should be set to 1 to prevent the SCA asynchronous handler from being triggered during retry. Note: Setting the retry count to 1 can prevent WebSphere Process Server recovery from generating failed events in some scenarios.
   
 * Avoid browsing messages in queues using the administrative console, if any message contains large objects.
   
 * Be aware that the WebSphere Integration Developer unit-test environment introduces additional serialization of objects, which further limits business object size. 
   
   
   

Memory leaks 

The J9 Java™ virtual machine (JVM) solves the problem with spurious object references that occur during heap compaction. The JVM for WebSphere Process Server 6.0.2 is enabled for J9, but J9 is currently not enabled, by default, and is not officially supported. 

Additional actions to consider: 
 * Tune the heap to optimize memory allocations. The buffer memory allocation scheme used by ByteArrayOutputStream is not optimized for contiguous memory usage, so heap fragmentation contributes to heap problems. 
   

Minimizing heap fragmentation: 
 * Set the heap min to a smaller starting value, or do not specify a heap min at all. What this does is encourages garbage collections with compaction that will ensure larger areas of free contiguous memory.
   
 * Use the -Xk and -Xp arguments to set the space allocated for pinned objects. Pinned objects can cause fragmentation by dividing an otherwise contiguous space. Determine the correct settings by using -Dibm.dg.trc.print=st_verify, and monitor the verbose gc output for the reported values. Refer to this Avoiding Java heap fragmentation with Java SDK V1.4.2 document for more information.
   
 * Allocate a percentage of the heap for large objects by using the -Xloratio argument. Refer to this How to allocate large objects into Large Object Area on IBM SDK 1.4.2 and later document for more information.
   

Tuning the heap is a good practice and should affect heap behavior, but is not likely to solve the problem entirely. After appropriate tuning, benchmark the application and the environment to determine specific limits. Note the following: 
 * It is difficult to predict a specific business object size limit. Neither the size of available heap nor the size of business object XML files are indicators. Therefore, benchmark to see what the limits are for a particular environment, and then compare maximum business object sizes against business object size requirements, and make application design decisions from there.

 * Using the planned heap configuration, with all other users of the heap in operation, determine the size limits of business objects by monitoring the environment during business object processing spanning a period of repetitive operations. Once limits are reached, try further tuning, or reduce business object size until a problem-free steady state is possible.
   
   

Consider the following options for the design of the application or scenario: 
 * Use smaller or less complex business objects. Consider one or both of the following: breaking up business objects into smaller entities and reducing the complexity of the business object into a flatter structure, to reduce the size of memory allocation requests.
   
 * Use a custom binding. The use of a custom binding provides both a way to avoid the single ByteArrayOutputStream serialization operation per large business object, used by the default binding, and options for handing large business objects differently.
   
   One option for dealing with large business objects includes serializing large business objects into smaller bundles, which can be either transferred to JMS using multiple writes, or written to a database as binary large objects (BLOBs), while using JMS to transmit the identifiers of those BLOBs. 
   
   The receiver uses a mirrored custom data binding to reassemble the data from the BLOBs. After the data is reassembled and the large business object is constructed in memory, it can be presented to the target service synchronously.

 

Cross reference information Segment Product Component Platform Version Edition Business Integration WebSphere Enterprise Service Bus General AIX, HP-UX, i5/OS, Linux, Solaris, Windows 7.0, 6.2, 6.1.2, 6.1, 6.0.2, 6.0.1