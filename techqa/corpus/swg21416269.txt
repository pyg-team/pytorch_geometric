Title: IBM valnt00095995 TQL Server performance improvements - United States

Text:
 FIX README

THIS DOCUMENT APPLIES ONLY TO THE FOLLOWING LANGUAGE VERSION(S):
 English 

ABSTRACT
 There are 2 performance improvement fixes made under this; TQL DB index pre-hashing as well as lightweight time support for DECALPHA platform. This document serves as user guide on how to use these features. This fix is available since NPR 3.6.2 Interim Fix 2 

CONTENT
 

Introduction 

This document is divided into 2 main sections, first discusses about TQL DB index pre-hashing fix details. This applicable for all platforms. Second is on lightweight time support for DECALPHA which applicable only for DECALPHA platform. 


valnt00097470: TQL Server improved pre-hash algorithm for system indexes as well as user relations

TQL DB has mechanism to pre-hash string column keys to produce a compact key. The benefit of doing so is to reduce the size of index, thus improves processing speed.

Current pre-hash algorithm used for system indexes are less efficient for today large database size requirement. Therefore 2 new pre-hash algorithm types have been introduced while retaining current pre-hash type for compatibility.

Listed below are TQL system variables, TQL system configuration, TQL system column, TQL function as well as TQL modifiers that are effected by this feature:
1. %PREHASH (An existing but previously undocumented TQL system variable)
2. %HASHTYPE (A new TQL system variable)
3. %DBHASHTYPE (A new TQL system configuration)
4. %KFLAGS (An existing but previously was unexposed system column)
5. IDXINFO (A new TQL function)
6. PREHASH0 (A new TQL modifier)
7. PREHASH1 (A new TQL modifier)
8. PREHASH2 (A new TQL modifier)

Refering to above items, following are a brief note on each. 

%HASHTYPE, %DBHASHTYPE and IDXINFO use following integer values for their references:
1. 0 for legacy pre-hash type, pre-hash type 0 (2 bytes)
2. 1 for new pre-hash, pre-hash type 1 type (4 bytes)
3. 2 for new pre-hash, pre-hash type 2 type (8 bytes)

%PREHASH is a boolean type variable. 

All above TQL modifiers are used within TQL INDEX command. 

While %KFLAGS is a new exposed column of %KEYS system relation to be used together with IDXINFO function, discussed later in this document.

Note: Each database should have been repaired with minimum repair level in order to have %KFLAGS column exposed. Refer to NPR 3.6.2 IF 2 installation Guide.

The difference between type 0, type 1 and type 2 is the trade off between pre-hash strength versus disk space consumption by the indexes i.e. type 1 has better strength compared to type 0 but also uses bigger space footprint. 

These variables/configuration can be used for 2 different areas within TQL database

1. System Relation Indexes (Recommended to upgrade)
2. User Relation Indexes (Optional)

System Relations Indexes

Generally system indexes are best pre-hashed at type 1. Current system indexes hash type can be verified by executing following TQL commands :


%PRINT %DBHASHTYPE


For existing database, these are the steps to alter the pre-hash type.

1. Bring down NPR system and lock the database

2. Drop all system indexes for the database

DROP INDEX FROM %RELATNS
DROP INDEX FROM %INDEXES
DROP INDEX FROM %COLS
DROP INDEX FROM %ITEMS
DROP INDEX FROM %KEYS
DROP INDEX FROM %PRIVS


3. Configure %DBHASHTYPE for the database to a desired hash type.

CONFIGURE DATABASE <dbname> SET %DBHASHTYPE <type_num>


4. Rebuild all system indexes for the database

INDEX %RELATNS
INDEX %INDEXES
INDEX %COLS
INDEX %ITEMS
INDEX %KEYS
INDEX %PRIVS


5. Verify the changes

%PRINT %DBHASHTYPE


As for new database, pre-hash type can be specified within TQL CREATE DATABASE command :


CREATE DATABASE <dbname> ON <dbloc> CONFIGURE SET %DBHASHTYPE <type_num>



User Relation Indexes

TQL Server %PREHASH system variable can be traced back since NPR 3.2. When %PREHASH is enabled on a session, any user relation index that contain string key created thereafter will be pre-hashed. By default, %PREHASH value is set to FALSE.

The new system variable, %HASHTYPE is introduced to allow user to specify pre-hash type when %PREHASH is enabled. By default, %HASHTYPE value follows %DBHASHTYPE value.

Following is an example to enable pre-hashing type 1

SET %HASHTYPE 1
SET %PREHASH TRUE
INDEX <tabname> BY <key-list>


Another method to accomplish the same as above is by using PREHASHn modifiers as follow:


INDEX <tabname> PREHASH1 BY <key-list>


Note, the later is recommended, as it more vocal to error handling, while the former method tend to discard pre-hash silently whenever it detects violation. This violation condition is discussed later.

The general guideline on choice of pre-hashing type for an user relation indexes are as follow:

1. Type 0 is recommended for relation with less than one thousand rows of data
2. Type 1 is recommended for relation with less than one million rows of data
3. Type 2 is recommended for relation with more than one million rows of data

However it is important to understand few pre-hash limitations before pre-hash indexes. The limitations are listed below.
1. Comparison operation for the pre-hashed string key is limited to equal and non-equal only. Hence the key cannot be used on greater or lesser comparisons. for example:

Taking following relations as an example for our illustration.


CREATE ITEM COL1 AS LONG(8)
CREATE ITEM COL2 AS STRING(10)
CREATE TAB1 AS COL1 PRIMARY, COL2 NULL 
INDEX TAB1 PREHASH1 BY COL2, COL1
INSERT 1 AS COL1, "ROW1" AS COL2 TO TAB1
INSERT 2 AS COL1, "ROW2" AS COL2 TO TAB1
INSERT 3 AS COL1, "ROW3" AS COL2 TO TAB1



This basically causes COL2 which is type of STRING to be pre-hashed, COL1 is unaffected. 

Following are list of queries and indications whether or not the pre-hashed index will be used for the queries. 


DISPLAY * FROM TAB1 WHERE COL1 = 2 AND COL2 = "ROW2"

The index will be used for this query 


DISPLAY * FROM TAB1 WHERE COL1 = 2 AND COL2 <> "ROW1" 

The index will be used for this query 


DISPLAY * FROM TAB1 WHERE COL1 = 2 AND COL2 > "ROW1" 

The index will NOT be used for this query 


DISPLAY * FROM TAB1 WHERE COL1 = 2 AND COL2 <= "ROW2" 

The index will NOT be used for this query 


DISPLAY * FROM TAB1 WHERE COL1 > 2 AND COL2 = "ROW3" 

The index will be used for this query 


DISPLAY * FROM TAB1 WHERE COL1 < 2 AND COL2 <> "ROW1" 

The index will be used for this query 

2. Pre-hash index is not used for sequencing/sorting. For example: 

Using the same TAB1 example as above 


SEQUENCE TAB1 BY COL2, COL1


The following command will not use the pre-hash index, instead a new index is created. However, it is possible to explicitly set the pre-hash index as sequence index by: 


SEQUENCE TAB1 BY INDEX 1

Be aware that such sequencing will not obey alphabetical order for its display sequence. 

3. Pre-hash is prohibited on unique indexes. For example 

Using the same TAB1 example as above 


INDEX TAB1 UNIQUE PREHASH1 BY COL2, COL1


Will cause TQL Server to throw query error -245 (PREHASHn modifier is not allowed on unique indexes). 
Note: Index creation using %PREHASH method will not throw this error however, pre-hashing is silently ignored. 

Hence of all the above mentioned user relation pre-hashing features, now there is a need to monitor and preserve pre-hash settings. TQL IDXINFO function is introduced for this purpose. Syntax of this function is as follow: 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * 

For example: 


DISPLAY %INAME, IDXINFO(%KFLAGS, "PREHASH") FROM %KEYS WHERE %RNAME = "TAB1"


returns TAB1 relation's indexes keys pre-hash status, 1 if enabled otherwise 0. Non-string key will always be 0. 


DISPLAY %INAME, IDXINFO(%KFLAGS, "TYPE") FROM %KEYS WHERE %RNAME = "TAB1" 

returns TAB1 relation's indexes keys pre-hash type, 0 for pre-hash type 0, 1 for pre-hash type 1 and 2 for pre-hash type 2. 

Note: Currently this feature is recognised by xdbio utility as well as Admin module maintenance section. 


valnt00096006 : TQL Server to use kernel device heartbeats for lightweight system time (DECALPHA only) 

This fix enables lightweight time method for TQL Server running in DECALPHA platform. This lightweight time method reduces kernel load by reducing number of time(2) system calls, thus should improve overall NPR performance as well. 

Refer to NPR System Administrator's Guide (Chapter 5, Database Performance Tuning, Environment variable) for further information. Note that unlike Solaris or HP-UX platform lightweight method, this fix does not buffer time(2) system call but rather gets the readings directly from kernel device heartbeats. With this, NPR on DECALPHA platform now defaults to lightweight method where possible. 

In order to enable this feature: 
1) Shut down NPR system 
2) Log in as root user 
3) Create a special character file 
# mknod /dev/tqltime c 15 0 
4) Enable read permission for all users 
# chmod a+r /dev/tqltime 
Note: This special file /dev/tqltime remains on the system across reboots. 
5) Log in as metrica user 
6) Make sure QY_TIME_METHOD environment is not set 
$ unset QY_TIME_METHOD 
7) Remove QY_TIME_METHOD from NPR environment source file (if any)  

HISTORICAL NUMBER
 1.0 

PRODUCT ALIAS/SYNONYM
 Network Performance Manager