Title: IBM Effective Address Overflow - United States

Text:
PERFM TECHNOTE (TROUBLESHOOTING)

PROBLEM(ABSTRACT)
 This document describes the cause and effect of Effective Address Overflow (EAO) exception VLOGs found in the Licensed Internal Code Log in the System Service Tools (SST). 

RESOLVING THE PROBLEM
EAO Definition 

EAO (Effective Address Overflow) occurs during program execution. User programs, XPF programs, and SLIC programs can get EAOs. EAOs occur due to address generation of instruction execution. (More on that later.) The increased execution time for the instruction that caused the EAO results in a longer runtime for that job, slower response time (if it is an interactive job), and increased CPU utilization for the system. EAO exceptions do not indicate that an error has occurred in the program that caused the EAO or the operating system. They are handled by SLIC and are not normally observed by developers or users. However, it can increase program runtime by two to twenty times (2x to 20x) what the program would require if the program did not cause EAOs, and increase CPU utilization to or near 100% while EAOs occur at a rapid rate.

EAO Causes

Instructions that access or change main storage often specify a register and displacement to address the operand in main storage. The hardware must generate the address of the operand to execute the instruction. This address generation is simply the addition of the register and the displacement. The hardware is set up to do a two-byte addition, if the addition causes a carry out of the rightmost two bytes, then an EAO results. (The addition overflows the two byte adder.) The hardware can address 64 K bytes with the two byte addition. If the sum of the register and displacement crosses a 64 K byte boundary, then an EAO occurs. If this happens, then the hardware cannot execute the instruction and instead signals an EAO exception.

The example below illustrates how the addressing can cause EAOs. Assume that the instruction uses register 4 and displacement F60. The sum of the base plus displacement causes the effective address to overflow the two byte adder (this also crosses the 64 K byte boundary in storage). 

SLIC Exception Handler

An EAO exception handler program (in SLIC) is executed to emulate the instruction. The program does the address generation (without itself causing EAOs), executes the instruction, and returns to the program that caused the exception. The exception handler also adds an EAO Threshold entry to the SLIC log when 16,384 EAOs have occurred and optionally traces the EAOs in an internal EAO trace area. 

Performance Impact

Some EAOs will occur on systems running IBM® OS/400® or IBM® i5/OS™ (until the hardware is changed so that it can handle all valid register/displacement combinations). If the EAO rate is low then the performance impact will be negligible. Only high EAO rates result in a performance problem. One guideline used by the performance advisor is if the EAO rate will add 5% to the processor utilization, then there is a possible performance problem. Another guideline uses the SLIC log. If two or more EAO Threshold entries occur in one minute. Each entry is time stamped. The following example shows a high EAO rate that occurred at 1:16 PM.



Select Entries from SLIC Log

Type options, press Enter to dump entry to selected device.
1=Printer 2=Tape 3=Diskette 5=Display Entry 8=Display Note

Note Major Minor
Opt ID Description Code Code Date Time

_ 010DC7 EAO threshold 0404 0000 03/13/91 13:16:07 
_ 010DC8 EAO threshold 0404 0000 03/13/91 13:16:59 
_ 010DC9 EAO threshold 0404 0000 03/13/91 13:17:47 
_ 010DCA EAO threshold 0404 0000 03/13/91 13:18:34 
_ 010DCB EAO threshold 0404 0000 03/13/91 13:19:23 
_ 010DCC EAO threshold 0404 0000 03/13/91 14:35:57 
_ 010DDB EAO threshold 0404 0000 03/14/91 10:55:17 
_ 010DDD EAO threshold 0404 0000 03/14/91 12:06:16 
_ 010DDE EAO threshold 0404 0000 03/14/91 12:07:27 
_ 010DDF EAO threshold 0404 0000 03/14/91 12:08:39 
_ 010DE0 EAO threshold 0404 0000 03/14/91 13:30:39 
_ 010DE2 EAO threshold 0404 0000 03/14/91 13:55:19 
_ 010DE3 EAO threshold 0404 0000 03/14/91 14:22:09 
_ 010DEA EAO threshold 0404 0000 03/15/91 10:26:46

F3=Exit F12=Cancel The advantage of using SLIC log is that it tells you when the high EAO rate started and ended. Unfortunately, it does not give you information about the job or program that caused the EAOs. 

EAOs tend to be bursty when they are a performance problem. They tend to occur with specific jobs and/or programs. If the system is running many users or batch jobs, then the severity of the performance degradation is masked by the normal system operation. For example, if a batch job is getting high rates of EAOs and interactive jobs preempt the batch job, then the EAO rate will be decreased. When the batch job runs, then the EAO rate will be high, then an interactive job preempts the batch job, then the EAO rate will be low. If all the jobs on the system have equal priority and one job has high EAO rate, then that job will tend to use its internal time slice (500 msecond of CPU time) and then give up the CPU for the other jobs of equal priority. Again, this will tend to reduce the overall EAO rate. 

Causes of EAOs and Avoiding EAOs 

Allocating structures in a space. If the program created a space and is allocating multiple structures in that space, this can result in EAOs. If the length of the structure is not a power of two (2, 4, 8, ..., up to 512 bytes), then it is likely that some structures cross a 64 K boundary. Accessing the fields in the structure that crosses the 64 K boundary can result in EAOs. A good way to avoid EAOs is to make the length of the structure a power of two. Another method is to test if an allocated structure can get EAOs. If the allocated structure can cause EAOs, then allocate another structure and discard (do not use) the first allocation. 
Using Large Amounts of Automatic Storage 

Program automatic storage is allocated in a space. Again there is a base register pointing to the beginning of the automatic storage for the program. Automatic storage variables are accessed via the base register and displacements in the program instructions. If a program has more than 64 K bytes of automatic storage, then it will cross at least one 64 K boundary, and EAOs can occur. Also, if the automatic storage for a program begins just before the 64 K boundary, then accessing each program variable will result in an EAO. This type of EAO can occur in PL/I, C, and Pascal and will result in very high EAO rates and severe performance degradation. 

There are several ways to avoid automatic storage EAOs. Some methods may not be effective after changes are made to the application that calls the program that has automatic storage EAOs. o If program A calls program B and program B gets automatic storage EAOs, then adding storage to program A can push the program B automatic storage past the 64 K boundary and avoid EAOs. This method will not work if there are many called subroutines. Also if there are changes to program A or the programs that call program A, then the EAOs can reappear. o Move large blocks of auto storage to static or allocated storage. o For PL/I programs, there is a fix that will avoid EAOs. For Release 2 and 3 programs, get the fix for PL/I and recompile the programs with option GENOPT(*PATCH). This will cause the program to recognize when the automatic storage area is near the 64 K boundary on a call and to skip to the boundary when allocating automatic storage. o Move often used variables to the start of the program automatic storage. The first 4 Kbytes are less prone to EAOs and generates superior code to access the variables. 


Cross reference information Segment Product Component Platform Version Edition Operating System IBM i 7.1 Operating System IBM i 6.1 
HISTORICAL NUMBER
 3571405