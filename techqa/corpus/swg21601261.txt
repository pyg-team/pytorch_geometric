Title: IBM Requirements for NLS_COMP and NLS_SORT Oracle database settings for Process Engine. - United States

Text:
NLS; TroubleshootingGuideDocument; ProvenPractices TECHNOTE (TROUBLESHOOTING)

PROBLEM(ABSTRACT)
 The current P8 documentation neglects to include the requirements to ensure that for Process Engine on Oracle database, the NLS_COMP and NLS_SORT environment variables needs to be identical. 

SYMPTOM
1) Some Process Engine (PE) user environment records may not be updated or migrated during an upgrade from Process Engine 3.5 .

2) Process Engine queries might not return all of the expected results.


CAUSE
Mismatching the NLS_COMP and NLS_SORT settings in an Oracle database can cause queries in the Process Engine to return incorrect results at run-time or cause certain PE user environment records to be skipped during a Process Engine upgrade. 

NLS_SORT specifies the collating sequence for an ORDER BY clause and NLS_COMP specifies the collating sequence for comparisons in a WHERE clause. The NLS_COMP setting affects the behavior of a test for "greater than" or "less than" in a WHERE clause of a select statement. 

NLS_COMP and NLS_SORT can be set to BINARY or they can be set to a linguistic (language specific) order. For correct operation, the Process Engine requires that NLS_COMP and NLS_SORT use the same setting.

The problem that can occur if NLS_COMP and NLS_SORT are not set the same is illustrated here using an example based on the Dutch language:


Consider a table like this: 

create table TestTable (A1 varchar(20));
Insert 6 rows into the table with values of A1 being 'a', 'b', 'c', '1', '2', and '3'. 

In SQLPlus you can do this:

alter session set NLS_SORT='BINARY';
alter session set NLS_COMP='BINARY';

select * from TestTable order by A1;

A1
---
1
2
3
a
b
c

In BINARY sorting, digits are before letters. 

If the Process Engine had taken a chunk of three rows, the query to get the next chunk would issue this query:

select * from TestTable where A1 > '3' order by A1;

And that would return a, b, and c - which is what is expected. 
In this case, the selection (controlled by NLS_COMP) matches the "order by" ordering (controlled by NLS_SORT). 

A problem will show up if the NLS_SORT is changed as follows:

alter session set NLS_SORT='DUTCH';

select * from TestTable order by A1;

A1
---
a
b
c
1
2
3

The "order by" now puts 1, 2, and 3 after the letters because the DUTCH setting for NLS_SORT puts digits after letters. 

But NLS_COMP is still set to BINARY, so the "where condition" collating sequence no longer matches the collating sequence used by sort. If the Process Engine had fetched the first three records as a chunk, it would then come back in later to get the next chunk with this query:

select * from A1 where A1 > 'c' order by A1;

We want to get 1, 2, and 3 (the records that we didn't yet fetch).
But that query returns no records because of the "greater than c" WHERE clause. 
As in the first case, the BINARY comparison says that numbers are before letters, so there are no records that have A1 > 'c'. 

There is a difference between the behavior of the comparison in the where condition and the comparison used for the sort order. 

The Process Engine uses a common coding technique that relies on 'order by' and 'where' condition comparisons using the same collating sequence. 

For example, when working with user environment records, the Process Engine generally grabs them in chunks of 50, sorted by the user name. It remembers the name of the last user in a chunk, and later comes back in and gets the next chunk of users, asking for more users sorted by name, with a name greater than the ending name in the previous chunk. 

But because the 'order by' gives one order and 'greater than' doesn't match, this query will skip users. 
In the above example, if we were grabbing users in chunks of 3, the first chunk would be users a, b, and c. Then, we'd say give us the users greater than 'c' and because of the comparison setting, we'd get "no more" users. And we'd completely miss users 1, 2, and 3. This is what can happen when migrating user environment records from Process Engine 3.5 or eProcess 5.2 up to Process Engine 4.x or Process Engine 5.x. 

Other areas of the Process Engine server software expect to be able to make similar queries. 

Always make sure the NLS_SORT and NLS_COMP settings are using the same collating sequence. 

This requirement only applies to Oracle databases.


ENVIRONMENT
Process Engine using an Oracle database.



DIAGNOSING THE PROBLEM
Run the following SQL query from SQL*Plus: 

 
select * from nls_database_parameters;

Verify that the values for NLS_SORT and NLS_COMP are the same. 


RESOLVING THE PROBLEM
 

Make sure that the NLS_SORT and NLS_COMP are both set to BINARY.
If the server machine locale is not en/US, pass the following parameters to the JVM that runs the Process Engine: -Duser.language=en -Duser.region=US -Duser.country=US 

These parameters must be used, regardless of the language and country of the customer, because if the JVM locale is not US English, the Oracle JDBC driver will issue an alter session command to change the NLS_SORT setting, which will cause the problem described in this technote. 
Refer to Oracle documentation for information on how to set NLS_SORT and NLS_COMP for your database.