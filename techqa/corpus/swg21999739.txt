Title: IBM SQL stored procedure started to loop after upgrade of DB2 version - United States

Text:
SQL stored procedure; loop; declare cursor; fetch; select ; insert into the same table; insert; looping TECHNOTE (TROUBLESHOOTING)

PROBLEM(ABSTRACT)
 Working stored procedure started to loop after DB2 upgrade 

SYMPTOM
Drasticly increased execution time for the stored procedure after database migration to the higher version 


CAUSE
Stored procedure opens cursor for select from some table and inside the stored procedure we do insert into the same table during fetch from a cursor.

ENVIRONMENT
Any supported operating systems, DB2 v9.7 and higher

DIAGNOSING THE PROBLEM
Run the stored procedure and compare execution time with the time it usually takes for stored procedure prior to upgrade. You even might see that stored procedure execution never completes.

RESOLVING THE PROBLEM
Here is a reproduction testcase that shows the problem when we fetch from the cursor opened for select and insert into the same table during fetch :

File: sp_test.db2

drop table t1%
create table t1(c1 int)%
insert into t1 values (1), (1), (1)%

CREATE OR REPLACE PROCEDURE loop (out inserts int)
LANGUAGE SQL
NOT DETERMINISTIC
MODIFIES SQL DATA
BEGIN
DECLARE MY_INT INTEGER;
DECLARE SQLCODE INTEGER DEFAULT 0;

DECLARE CUR1 CURSOR FOR SELECT C1 FROM T1;

DECLARE EXIT HANDLER FOR SQLEXCEPTION
BEGIN
END;

OPEN CUR1;
FETCH FROM CUR1 INTO MY_INT;
set inserts=0;

WHILE (SQLCODE = 0) DO
INSERT INTO T1 VALUES(1);
set inserts=inserts+1;
FETCH FROM CUR1 INTO MY_INT;
END WHILE;

END%

call loop(?)% 

Our testcase inserts 3 rows into table and execution of the testscript gives the following output:

db2 -td% -vf sp_test.db2

......
FETCH FROM CUR1 INTO MY_INT;
END WHILE;
END
DB20000I The SQL command completed successfully.

call loop(?)

Value of output parameters
--------------------------
Parameter Name : INSERTS
Parameter Value : 336305
Return Status = 0

336305 rows were inserted while only 6 rows were expecting to be in the table after the stored procedure call: 3 original rows and 3 new inserted rows.

Here is a reason of so many rows to be inserted into table:

There is a cursor declared on the T1 table and the while loop is both inserting to and fetching from it. This means that result set materialization of the cursor can occur during insertion, i.e. if you insert a row into the table after the current row the cursor is on, the cursor may see that row during a subsequent fetch.






In order to solve the problem the cursor has to be materialized only at OPEN time. 

Here is how it could be done: 


1> Starting in v9.7, you can declare a cursor to be INSENSITIVE to force it to materialize only at OPEN time. 

Change declare cursor in your stored procedure like this: 

DECLARE CUR1 CURSOR INSENSITIVE FOR SELECT C1 FROM T1; 

and recompile the stored procedure. 

 

2> You can also do this for all cursors defined as WITH RETURN by setting bit position number 13 (0x1000) of the DB2_COMPATIBILITY_VECTOR registry variable: 

db2set DB2_COMPATIBILITY_VECTOR=1000 

db2stop force 

db2start 

Change the declare cursor statement for the stored procedure to: 

 DECLARE CUR1 CURSOR WITH RETURN FOR SELECT C1 FROM T1;


Recompile the stored procedure. 

 

3> You can set up STATICREADONLY to INSENSITIVE before creation of the stored procedure by running:

db2 CALL SET_ROUTINE_OPTS('STATICREADONLY INSENSITIVE')

or by setting DB2 registry:

db2set DB2_SQLROUTINE_PREPOPTS="STATICREADONLY INSENSITIVE" 
db2stop force 
db2start


Recompile the stored procedure. 




More information about INSENSITIVE CURSOR could be found here: https://www.ibm.com/support/knowledgecenter/SSEPGG_9.7.0/com.ibm.db2.luw.apdv.porting.doc/doc/r0057253.html [https://www.ibm.com/support/knowledgecenter/SSEPGG_9.7.0/com.ibm.db2.luw.apdv.porting.doc/doc/r0057253.html]