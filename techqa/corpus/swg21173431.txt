Title: IBM Unexplained System.gc() calls due to Remote Method Invocation (RMI) or explicit garbage collections - United States

Text:
JDK; Java SDK; outofmemory; heap; memory exception; RMI; remote; invocation; runtime.gc; disableexplicit; disableexplicitgc; explicitgc TECHNOTE (TROUBLESHOOTING)

PROBLEM(ABSTRACT)
 You observe a pattern of explicit garbage collection on a regular interval (usually every 60 seconds), but the application does not contain any System.gc() calls. The problem might be Remote Method Invocation (RMI) distributed garbage collection. 

CAUSE
Excessive garbage collection affects Javaâ„¢ Virtual Machine (JVM) performance.

RESOLVING THE PROBLEM
RMI uses a distributed garbage collection (DGC) algorithm that depends on regular garbage collection (GC) activity to determine if remote objects are candidates for collection. It helps with automatic memory management when remote objects are stored in memory. More information can be found at the links below: 

Understanding distributed garbage collection (IBM SDK 7.0 / 7.1) [http://www-01.ibm.com/support/knowledgecenter/SSYKE2_7.0.0/com.ibm.java.win.71.doc/diag/understanding/rmi_dgc.html?lang=en]
Understanding distributed garbage collection (IBM SDK 6.0) [http://www-01.ibm.com/support/knowledgecenter/SSYKE2_6.0.0/com.ibm.java.doc.diagnostics.60/diag/understanding/rmi_dgc.html?lang=en]


To ensure that the remote objects are collected in a timely fashion, RMI takes the step of triggering a System.gc() on a regular interval. However, in most cases regular GC activity is sufficient for effective DGC. 

Example of verboseGC data that shows 60 second garbage collection intervals based on timestamps:



<GC(385): Bytes Traced =0 (Foreground: 0+ Background: 0) State = 3 >
<GC(385): mark stack overflow[107]>
<GC(385): GC cycle started Wed May 24 00:17:392006
<GC(385): heap layout: (321330848/429495496) (107373880/107373880) /0>
<GC(385): freed 6288024 bytes, 79% free (428704728/536869376), in 1075 ms>
<GC(385): mark: 161 ms, sweep: 19 ms, compact: 895 ms>
<GC(385): refs: soft 0 (age >= 32), weak 2, final 167, phantom 0>
<GC(385): moved 43776 objects, 3486944 bytes, reason=16>

<GC(386): Bytes Traced =0 (Foreground: 0+ Background: 0) State = 3 >
<GC(386): GC cycle started Wed May 24 00:18:402006
<GC(386): heap layout: (321320752/429495496) (107373880/107373880) /0>
<GC(386): freed 6286376 bytes, 79% free (428694632/536869376), in 1041 ms>
<GC(386): mark: 128 ms, sweep: 19 ms, compact: 894 ms>
<GC(386): refs: soft 0 (age >= 32), weak 2, final 170, phantom 0>
<GC(386): moved 21831 objects, 2667880 bytes, reason=16> 

Generic JVM Arguments 
You will need to set the JVM arguments below from the Administration Console. This will require a restart of your server. For detailed instructions, please read the technote Where to set generic JVM arguments in WebSphere Application Server [http://www.ibm.com/support/docview.wss?uid=swg21417365] . 


 * RMI Garbage Collection Interval
 * 
 * 
 * 
 * 
 * 
 *  -Dsun.rmi.dgc.server.gcInterval=VALUE
   -Dsun.rmi.dgc.client.gcInterval=VALUE 
 * 
 * VALUE is in milliseconds. For example 60000 = 60 seconds.
 * 
 * 
 * 
 * 
 * 
 * 
 * 
 * Java 5.0
 * 
 * 
 * This was increased
 * 
 * 
 * 
 * 
 * 
 * Disabling Explicit Garbage Collections
 * 
 * 
 * 
 * 
 * 
 *  -Xdisableexplicitgc 
 * 
 * 
 *  -XX:+DisableExplicitGC 



Frequently Asked Questions 


Does disabling explicit garbage collections stop all System.gc() calls? 

The behavior depends if you are using the IBM SDK or Sun Java JDK. 
 * IBM SDK (AIX, Linux, Windows)
 * 
 * 
 * 
 * 
 * only 
 * 
 * 
 * 
 * 
 * Sun Java JDK (Solaris and HP-UX)
 * 
 * 
 * 
 * 
 * Java Bug 5025281
 * 



Do both server and client arguments need to be added? 

The two sun.rmi arguments reflect whether your JVM is running in server or client mode. Depending on the version of your SDK, either mode can be set as the default. It is best to set both options so the argument will be picked up by the JVM. 

Why do I still have full GCs occurring? 
The arguments above only affect full GCs related to the distributed garbage collector and explicit GCs that are kicked off by application code, respectively. Full GCs can still occur even with these options enabled, usually when the heap (or tenured/old regions) become full. 

Problems with excessive full GCs may indicate a completely different issue that is not covered by this document, which can include memory exhaustion, performance issues, among others. RELATED INFORMATION
 Listing of sun.rmi Properties [http://java.sun.com/j2se/1.5.0/docs/guide/rmi/sunrmiproperties.html]