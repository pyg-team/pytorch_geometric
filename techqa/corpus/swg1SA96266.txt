Title: IBM SA96266: MQM400 MCH3601 FROM + TO MODULE AMQXIINX_N FROM + TO PROCEDU - United States

Text:
 SUBSCRIBE
You can track all active APARs for this component.



APAR STATUS
 * CLOSED AS PROGRAM ERROR.
    
   
   

ERROR DESCRIPTION
 *  ******* (Do NOT alter/erase this or next 3 lines) *******
   * EQUIVALENT ABSTRACT:
   MQM400 MCH3601 FROM _ TO MODULE AMQXIINX_N FROM _ TO PROCEDU
   *
   Customer sees many jobs in SEMW. They do not go away even
   when the queue manager is ended. After running a diagnostic
   for this we were able to isolate it to a job in the
   AMQXIINX_N module at statement 35 in the procedure
   GetSubpoolsLock after a SYSREQ option 2 per:
   WRKUSRJOB User for jobs *ACTIVE.
   Option 8 ..until you find the job (you will have the
   job number) If you dont find it..this isnt the problem. STOP.
   If you do find it. Note the JOBname and Carry on to the next
   stage.
   DSPJOB number/user/Jobname
   Display the job log go to the end..F10 and page up.
   Look for the LAST Message:
   Message :   Pointer not set for location referenced.
   Take F1.
   If the details of the message are EXACTLY as follows
    MCH3601    Escape
     From module . . . . . . . . :   AMQXIINX_N
     From procedure  . . . . . . :   GetSubpoolsLock
     Statement . . . . . . . . . :   35
     To module . . . . . . . . . :   AMQXIINX_N
     To procedure  . . . . . . . :   GetSubpoolsLock
     Statement . . . . . . . . . :   35
   You have the problem..and need to end the job.
   IF
   Message is not MCH3601              OR
   MCH3601 for any other function      OR
   Statement number is not 35 for function GetSubpoolsLock
   STOP... its a different problem.
   The problem can be avoided by NOT taking SYSREQ2 after
   WRKMQMCHL.
   If a developer keeps a separate session for any WRKMQMCHL..
   and ENDS the session rather than taking SYSREQ2 this should
   prevent the lock occurring in the first place.
   The fix for the problem is extensive and is being worked
   under defect 73251
   The problem ONLY occurs when the cancel handler is called,
   if the call stack is outside the scope of the cancel handler
   we have no need to reinitialize the resources for the job -
   generally in MQ commands we are only in the scope of the
   cancel handler when in an MQI call (i.e. we have MQ resources
   to release) so this is a timing window. In summary - this
   lockup will never happen unless you hit SysReq-2 in a timing
   window and attempt to carry out any MQ activity without first
   signing off your session.
   
   
    
   
   

LOCAL FIX

PROBLEM SUMMARY
 *  Customer sees many jobs in SEMW. They do not go away even
   when the queue manager is ended. After running a diagnostic
   for this we were able to isolate it to a job in the
   AMQXIINX_N module at statement 35 in the procedure
   GetSubpoolsLock after a SYSREQ option 2 per:
   WRKUSRJOB User for jobs *ACTIVE.
   Option 8 ..until you find the job (you will have the
   job number) If you dont find it..this isnt the problem. STOP.
   If you do find it. Note the JOBname and Carry on to the next
   stage.
   DSPJOB number/user/Jobname
   Display the job log go to the end..F10 and page up.
   Look for the LAST Message:
   Message :   Pointer not set for location referenced.
   Take F1.
   If the details of the message are EXACTLY as follows
    MCH3601    Escape
     From module . . . . . . . . :   AMQXIINX_N
     From procedure  . . . . . . :   GetSubpoolsLock
     Statement . . . . . . . . . :   35
     To module . . . . . . . . . :   AMQXIINX_N
     To procedure  . . . . . . . :   GetSubpoolsLock
     Statement . . . . . . . . . :   35
   You have the problem..and need to end the job.
   IF
   Message is not MCH3601              OR
   MCH3601 for any other function      OR
   Statement number is not 35 for function GetSubpoolsLock
   STOP... its a different problem.
   The problem can be avoided by NOT taking SYSREQ2 after
   WRKMQMCHL.
   If a developer keeps a separate session for any WRKMQMCHL..
   and ENDS the session rather than taking SYSREQ2 this should
   prevent the lock occurring in the first place.
   The fix for the problem is extensive and is being worked
   under defect 73251
   The problem ONLY occurs when the cancel handler is called,
   if the call stack is outside the scope of the cancel handler
   we have no need to reinitialize the resources for the job -
   generally in MQ commands we are only in the scope of the
   cancel handler when in an MQI call (i.e. we have MQ resources
   to release) so this is a timing window. In summary - this
   lockup will never happen unless you hit SysReq-2 in a timing
   window and attempt to carry out any MQ activity without first
   signing off your session.
   
   
    
   
   

PROBLEM CONCLUSION
 *  Ending MQSeries processes using SYSREQ-2 has been made more
   robust.
   
   
    
   
   

TEMPORARY FIX

COMMENTS

APAR INFORMATION
 * APAR NUMBER
   SA96266
   
   
 * REPORTED COMPONENT NAME
   MQSERIES FOR AS
   
   
 * REPORTED COMPONENT ID
   5733A3800
   
   
 * REPORTED RELEASE
   520
   
   
 * STATUS
   CLOSED PER
   
   
 * PE
   NoPE
   
   
 * HIPER
   NoHIPER
   
   
 * SPECIAL ATTENTION
   NoSpecatt
   
   
 * SUBMITTED DATE
   2003-10-13
   
   
 * CLOSED DATE
   2003-10-13
   
   
 * LAST MODIFIED DATE
   2003-10-23
   
   

 * APAR IS SYSROUTED FROM ONE OR MORE OF THE FOLLOWING:
   
   
   
 * APAR IS SYSROUTED TO ONE OR MORE OF THE FOLLOWING:
   
   
   

MODULES/MACROS
 *  AMQWASCX
   
   
    
   
   

FIX INFORMATION
 * FIXED COMPONENT NAME
   MQSERIES FOR AS
   
   
 * FIXED COMPONENT ID
   5733A3800
   
   

APPLICABLE COMPONENT LEVELS
 * R520 PSY SF67755
   UP03/10/23 I 1000