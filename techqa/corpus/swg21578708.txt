Title: IBM Type Tree analysis encountered error 'undefined type' with a Type Tree created using Cobol CopyBook Importer - United States

Text:
WTX Mercator Ascential Cobol CopyBook Importer TECHNOTE (TROUBLESHOOTING)

PROBLEM(ABSTRACT)
 WebSphereÂ® Transformation Extender (WTX) Type Tree analysis error encountered with a Type Tree created using Cobol Copybook Importer. 

SYMPTOM
Error 'undefined type' encountered when analysing type tree created using Cobol Copybook importer.


CAUSE
Cobol Copybook contains a field with 'occurs depending on' clause at a lower level than the 'index' field.

ENVIRONMENT
The field that has the 'occurs depending on' clause is at a lower level than the 'index' field so when the component rule is created this field is not viable.

DIAGNOSING THE PROBLEM
In COBOL we can say that the data being parsed has a component that occurs a variable number of times (ODO or Occurs Depending On) based on some data that has already been parsed in the file. In COBOL that variable does not need to be a preceding sibling or 'cousin', .ie. can be anywhere in the file.


In the Cobol Copybook importer, we have to create a type tree using rules that WebSphere Transformation Extender will allow. In some cases, the results are automatic, in others, manual changes to either the copybook or the generated type tree will be required. 

In the cases of Occurs depending on Clauses, with WTX we model this with a component rule that says COUNT($)<={some previously parsed component}. If the {some previously parsed component } is a very close relative to the component that it controls, then the copybook importer will create a successful tree. For example, if we have the following copybook:

03 Group1.
05 Field1 pic x.
05 Field3 pic 9.
05 Field5 OCCURS 0 TO 500
DEPENDING ON
Field3.

the corresponding tree will have the following structure
FILE 
GROUP1 
Field1 
Field3 
Field5(0:500) COUNT($)<=Field3:GROUP1

and this will work fine. 

However, if the {some previously parsed component } is not at a field that is available during the WTX parsing time, manual modifications are needed. 

Here are two samples:

1) 03 Group1.
05 Field1 pic x.
05 Field3 pic 9.
05 Group2.
07 Field5 occurs 0 to 500 
DEPENDING ON Field3.


2) 03 Group1.
05 Field1 pic x.
05 Field3 pic 9.
03 Group2.
05 Field4 pic x.
05 Field5 OCCURs 0 to 500
DEPENDIG ON Field3.

In example 1, Field3 is not at the same level of Field5, but because Group2 is really not doing anything, Field5 can be moved to a 05 level instead of 07 so it can be at the same level as the ODO field. This implies changing the copybook (what we call flattening) to 
03 Group1.
05 Field1 pic x.
05 Field3 pic 9.
05 Field5 occurs 0 to 500 
DEPENDING ON Field3.

This will create a tree like mentioned at the beginning of the note,

In Example 2, we have a different scenario which cannot be resolved by modifying the copybook but instead will require a modification of the resulting type tree.

The tree created by the copybook will look like this:

FILE 
GROUP1 
Field1 
Field3 

GROUP2 
Field4 
Field5(0:500) COUNT($)<=Field3:GROUP1 

In this case, during WTX parsing time, Field3 is not available during evaluation of Field5 (this is what we call a cousin element). In this case, the component rule has to be moved to a different level. in this particular example the component structure in the type tree has to be:

FILE 
GROUP1 
Field1 
Field3 

GROUP2 COUNT(Field5:$)<=Field3:GROUP1 
Field4 
Field5(0:500) 

Where the component rule is moved to a higher location that has access to the previous required element.


RESOLVING THE PROBLEM
In some cases as described in the previous examples, Our advise is to flatten the structure in the copybook and re-import and in others to move the component rule to higher levels (some times even up to the root) in the generated type tree prior to analysing.





PRODUCT ALIAS/SYNONYM
 Ascential DataStage TX Mercator