Title: IBM Differences between Rational Rhapsody 8.0 Statecharts and UML 2.4.1 Behavior State Machine - United States

Text:
Restriction; Restrictions; Limitation; Limitations; drawing; graphical; graph; difference; diferences; gap; deffer; feature; features; concept; concepts; error; errors WHITE PAPER

ABSTRACT
 This is a white paper that explains the differences between IBM Rational Rhapsody 8.0.x Statecharts and UML 2.4.1 Behavior State Machine. 

CONTENT
 

Authors: Shinji Kanai, Moria Abadi


OMG UML and IBM Rational Rhapsody have been evolving in parallel, and some differences were created and expanded over time. Not all graphical notations that are defined in UML specification are supported by Rhapsody. There are certain patterns of transitions you cannot draw due to restrictions imposed deliberately, but not necessarily limited by UML specification. Some of UML features such as deferred event and do-activity are not natively supported today. This document covers such gaps that are found between UML specification and Rhapsody implementation, aiming to help you design statechart more effectively and enable easier interchange of statecharts among UML-based modeling tools.




Disclaimer This documentation is created based on differences that are found between Rhapsody 8.0.x Statechart and OMG UML 2.4.1 Superstructure Specification (UML spec). The content is believed to be accurate at the time of publication. Use this documentation at your own risk as it might contain some incompleteness and imprecision.



Table: Graphical Notations and Naming comparison 

UML2.4.1 Concept: Behavior state machine element or capability as it is named in OMG UML 2.4.1 Superstructure Spec. Section in spec: The section describing the element in UML spec. In Rhapsody: The corresponding name and graphical notation of UML concept that is used in Rhapsody. Note: Additional comments to help understand the specific concept better. 
[/support/docview.wss?uid=swg27040251&amp;aid=1] UML2.4.1 Concept Section in spec In Rhapsody Note 1. Entry Point
[/support/docview.wss?uid=swg27040251&amp;aid=2] 15.3.1 EnterExitPoint
[/support/docview.wss?uid=swg27040251&amp;aid=3] (*) Visualization using a rectangular symbol is not supported
(*) Not supported for composite states (See NO. 36). 2. Exit Point
[/support/docview.wss?uid=swg27040251&amp;aid=4] 15.3.1 EnterExitPoint
[/support/docview.wss?uid=swg27040251&amp;aid=5] (*) Visualization using a rectangular symbol is not supported
(*) Not supported for composite states, only for submachine states 3. Final State
[/support/docview.wss?uid=swg27040251&amp;aid=6] 15.3.2 Termination State
[/support/docview.wss?uid=swg27040251&amp;aid=7] [/support/docview.wss?uid=swg27040251&amp;aid=1] 4. Initial Pseudostate
[/support/docview.wss?uid=swg27040251&amp;aid=8] 15.3.8 Default Connector
[/support/docview.wss?uid=swg27040251&amp;aid=9] [/support/docview.wss?uid=swg27040251&amp;aid=1] 5. Deep History Pseudostate
[/support/docview.wss?uid=swg27040251&amp;aid=10] 15.3.8 History Connector

[/support/docview.wss?uid=swg27040251&amp;aid=11] [/support/docview.wss?uid=swg27040251&amp;aid=1] 6. Shallow History Pseudostate
[/support/docview.wss?uid=swg27040251&amp;aid=12] 15.3.8 Shallow History Connector
[/support/docview.wss?uid=swg27040251&amp;aid=13] (*) Code Generation is supported in v8.0.6. See technote 1668548 [http://www.ibm.com/support/docview.wss?uid=swg21668548] for more information. 7. Join Pseudostate
[/support/docview.wss?uid=swg27040251&amp;aid=14] 15.3.8 Join Sync Bar
[/support/docview.wss?uid=swg27040251&amp;aid=15] [/support/docview.wss?uid=swg27040251&amp;aid=1] 8. Fork Pseudostate
[/support/docview.wss?uid=swg27040251&amp;aid=16] 15.3.8 Fork Sync Bar
[/support/docview.wss?uid=swg27040251&amp;aid=17] [/support/docview.wss?uid=swg27040251&amp;aid=1] 9. Junction Pseudostate
[/support/docview.wss?uid=swg27040251&amp;aid=18] 15.3.8 Junction Connector
[/support/docview.wss?uid=swg27040251&amp;aid=19] (*) Used only for merge. Only one outgoing transition is permitted 10. Static Conditional Branch
[/support/docview.wss?uid=swg27040251&amp;aid=20] 15.3.8 Condition Connector
[/support/docview.wss?uid=swg27040251&amp;aid=21] (*) Only one incoming transition is allowed.
(*) Realized by way of the condition connector. 11. Terminate Pseudostate
[/support/docview.wss?uid=swg27040251&amp;aid=22] 15.3.8 termination Connector
[/support/docview.wss?uid=swg27040251&amp;aid=23] [/support/docview.wss?uid=swg27040251&amp;aid=1] 12. State List
[/support/docview.wss?uid=swg27040251&amp;aid=24] 15.3.8 [/support/docview.wss?uid=swg27040251&amp;aid=25] (*) This is an additional representation for transition from the junction having a history as target. the regular representation can be used instead. 13. Region
[/support/docview.wss?uid=swg27040251&amp;aid=26] 15.3.10 Region
[/support/docview.wss?uid=swg27040251&amp;aid=27] [/support/docview.wss?uid=swg27040251&amp;aid=1] 14. Simple State
[/support/docview.wss?uid=swg27040251&amp;aid=28] 15.3.11 Simple State
[/support/docview.wss?uid=swg27040251&amp;aid=29] [/support/docview.wss?uid=swg27040251&amp;aid=1] 15. Composite State
[/support/docview.wss?uid=swg27040251&amp;aid=30] 15.3.11 Composite State
[/support/docview.wss?uid=swg27040251&amp;aid=31] [/support/docview.wss?uid=swg27040251&amp;aid=1] 16. Submachine State
[/support/docview.wss?uid=swg27040251&amp;aid=32] 15.3.11 Sub-statechart
[/support/docview.wss?uid=swg27040251&amp;aid=33] [/support/docview.wss?uid=swg27040251&amp;aid=1] 17. Entry Behavior
[/support/docview.wss?uid=swg27040251&amp;aid=34] 15.3.11 Action on Entry
[/support/docview.wss?uid=swg27040251&amp;aid=35] [/support/docview.wss?uid=swg27040251&amp;aid=1] 18. Exit behavior
[/support/docview.wss?uid=swg27040251&amp;aid=36] 15.3.11 Action on Exit
[/support/docview.wss?uid=swg27040251&amp;aid=37] [/support/docview.wss?uid=swg27040251&amp;aid=1] 19. Behavior in state (do-activity)
[/support/docview.wss?uid=swg27040251&amp;aid=38] 15.3.11 [/support/docview.wss?uid=swg27040251&amp;aid=39] (*) Can be implemented using entry and exit actions. See appendix (*2) for additional information. 20. Deferred events
[/support/docview.wss?uid=swg27040251&amp;aid=40] 15.3.11 [/support/docview.wss?uid=swg27040251&amp;aid=41] (*) Can be modeled by customizing the framework. See appendix (*3) for additional information. 21. State Redefinition 15.3.11 State Redefinition (*) Class inheritance causes inheritance of statecharts. the inherited statechart can redefine its inherited states. 22. State Machine extension 15.3.12 State machine extension (*) through class inheritance 23. Time event
[/support/docview.wss?uid=swg27040251&amp;aid=42] 15.3.13 Time event
[/support/docview.wss?uid=swg27040251&amp;aid=43] (*) First option tm(<expression>), where<expression> is the number of time units. Second option Accept time event. 24. Transition 15.3.14 Transition (*) A transition cannot be associated with more than one trigger. Separate transitions for each trigger need to be used.
(*) See appendix (*4) for the list of known transaction patterns that are forbidden by Rhapsody. 25. Internal transition
[/support/docview.wss?uid=swg27040251&amp;aid=44] 15.3.14 Reaction in state
[/support/docview.wss?uid=swg27040251&amp;aid=45] [/support/docview.wss?uid=swg27040251&amp;aid=1] 26. Completion transition 15.3.14 Null transition [/support/docview.wss?uid=swg27040251&amp;aid=1] 27. Completion event 15.3.14 Null event [/support/docview.wss?uid=swg27040251&amp;aid=1] 28. Transition redefinition 15.3.14 Transition redefinition (*) Class inheritance causes inheritance of statecharts. the inherited statechart can redefine its transitions, except the source state and the trigger. 29. Signal receipt
[/support/docview.wss?uid=swg27040251&amp;aid=46] 15.3.14 Accept Event Action
[/support/docview.wss?uid=swg27040251&amp;aid=47] [/support/docview.wss?uid=swg27040251&amp;aid=1] 30. Signal sending
[/support/docview.wss?uid=swg27040251&amp;aid=48] 15.3.14 Send Action
[/support/docview.wss?uid=swg27040251&amp;aid=49] [/support/docview.wss?uid=swg27040251&amp;aid=1] 31. Action sequence notation
[/support/docview.wss?uid=swg27040251&amp;aid=50] 15.3.14 [/support/docview.wss?uid=swg27040251&amp;aid=51] [/support/docview.wss?uid=swg27040251&amp;aid=1] 32. Local transition
[/support/docview.wss?uid=swg27040251&amp;aid=52] 15.3.15 [/support/docview.wss?uid=swg27040251&amp;aid=53] [/support/docview.wss?uid=swg27040251&amp;aid=1] 33. Choice Pseudostate/Dynamic Conditional Branch
[/support/docview.wss?uid=swg27040251&amp;aid=54] 15.3.8 [/support/docview.wss?uid=swg27040251&amp;aid=55] (*) Can be simulated for example by using an additional state with guarded outgoing null transitions. See attachment (*1) in appendix. 34. Final Notation
[/support/docview.wss?uid=swg27040251&amp;aid=56] 15.3.8 [/support/docview.wss?uid=swg27040251&amp;aid=57] (*) {final} means that the state cannot be redefined (such as, extended). 35. Entry/Exit Point as part of submachine state graph
[/support/docview.wss?uid=swg27040251&amp;aid=58] 15.3.11 [/support/docview.wss?uid=swg27040251&amp;aid=59] [/support/docview.wss?uid=swg27040251&amp;aid=1] 36. Entry/Exit Point on composite state
[/support/docview.wss?uid=swg27040251&amp;aid=60] 15.3.8 [/support/docview.wss?uid=swg27040251&amp;aid=61] [/support/docview.wss?uid=swg27040251&amp;aid=1] 37. "Bracket" Entry/Exit Point notation 
[/support/docview.wss?uid=swg27040251&amp;aid=62] 15.3.1 [/support/docview.wss?uid=swg27040251&amp;aid=63] [/support/docview.wss?uid=swg27040251&amp;aid=1] 38. Referenced/Reused submachine state
[/support/docview.wss?uid=swg27040251&amp;aid=64] 15.3.11 [/support/docview.wss?uid=swg27040251&amp;aid=65] (*) Creation of submachine is supported, but cannot be reused/referenced elsewhere. 39. Multiple triggers for a transition
[/support/docview.wss?uid=swg27040251&amp;aid=66] 15.3.14 [/support/docview.wss?uid=swg27040251&amp;aid=67] [/support/docview.wss?uid=swg27040251&amp;aid=1] 40. Extended Notation
[/support/docview.wss?uid=swg27040251&amp;aid=68] 15.3.11 [/support/docview.wss?uid=swg27040251&amp;aid=69] (*) Similar effect is achievable but need to extend a whole class containing a state machine using generalization. 

Appendix: 


Disclaimer All source code or binaries attached to this document are referred to here as "the Program". IBM is not providing program services of any kind for the Program. IBM is providing the Program on an "AS IS" basis without warranty of any kind. IBM WILL NOT BE LIABLE FOR ANY ACTUAL, DIRECT, SPECIAL, INCIDENTAL, OR INDIRECT DAMAGES OR FOR ANY ECONOMIC CONSEQUENTIAL DAMAGES (INCLUDING LOST PROFITS OR SAVINGS), EVEN IF IBM, OR ITS RESELLER, HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.


#tbc 

#tbc 
(*1) Dynamic Conditional Branch 

DynamicBranch74orHigher.zip [/support/docview.wss?uid=swg27040251&aid=71]DynamicBranch74orHigher.zip [/support/docview.wss?uid=swg27040251&aid=70] 

#tbc 
(*2) 
there is a risk that is involved to support an execution of an action that is being performed while the owning object is in a certain state. For example, there is a state "WaitForInput" with Do Action reading an input from the console in the background. Now an event comes to trigger a transition - a need arose to interrupt the operation of reading the input - but there is no generic way to do such things for all operations unless the action is being performed in a different thread and kill this thread. this solution seems risky for embedded systems and considered inefficient. 

#tbc 
(*3) 
Rhapsody does not support deferred events, but there is an easy way to catch an event, which is not consumed, and process it according to your need. OMReactive class contains handleNotConsumed() virtual function, which can be overridden in your reactive class. This function is always called when event is not consumed. 


(*4)Transactional Restrictions - List of known transaction patterns that are forbidden by Rhapsody 



Multiple outgoing transitions from Exit Point [/support/docview.wss?uid=swg27040251&amp;aid=72] Transition to Condition Connector from Entry/Exit Point having multiple incoming transitions [/support/docview.wss?uid=swg27040251&aid=73] [/support/docview.wss?uid=swg27040251&aid=73]
[/support/docview.wss?uid=swg27040251&aid=74] [/support/docview.wss?uid=swg27040251&aid=74] Direct transition from Junction to Condition Connector [/support/docview.wss?uid=swg27040251&amp;aid=75] Indirect transition from Junction to Condition Connector by way of Entry/Exit Point [/support/docview.wss?uid=swg27040251&amp;aid=76] Direct transition from Join Bar to Junction [/support/docview.wss?uid=swg27040251&amp;aid=77] Direct transition from Junction to Fork Bar [/support/docview.wss?uid=swg27040251&amp;aid=78] Multiple incoming transition to Condition Connector [/support/docview.wss?uid=swg27040251&amp;aid=79] Set a trigger on a transition that is originated from Exit Point [/support/docview.wss?uid=swg27040251&amp;aid=80] 
RELATED INFORMATION
 UML 2.4.1 Superstructure [http://www.omg.org/spec/UML/2.4.1/Superstructure/PDF/]
Enhancement for Do Activity [http://www.ibm.com/developerworks/rfe/execute?use_case=viewRfe&CR_ID=8817]
Enhancement for Dynamic Condition Connector [http://www.ibm.com/developerworks/rfe/execute?use_case=viewRfe&CR_ID=7832]
Enhancement for Shallow History Connector [http://www.ibm.com/developerworks/rfe/execute?use_case=viewRfe&CR_ID=5916]
Enhancement Deferred Event [http://www.ibm.com/developerworks/rfe/execute?use_case=viewRfe&CR_ID=12691]