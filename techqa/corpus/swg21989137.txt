Title: IBM Lock timeouts (SQL0911N) even when WITH UR requested on a SELECT statment.  Why? - United States

Text:
SQL0911N; WITH UR; lock; timeout; cursor; NS; X; BLOCKING TECHNOTE (FAQ)

QUESTION
 Lock timeouts (SQL0911N) even when WITH UR requested on a SELECT statment. Why? 

CAUSE
If you take a lock snapshot and review, you will see a NS requestor is locked out by a X holder, even with UR. Why is that? 
If you review the IBM DB2 documentation for "Lock Type Compatibility" here:

http://www.ibm.com/support/knowledgecenter/SSEPGG_10.5.0/com.ibm.db2.luw.admin.perf.doc/doc/r0005274.html [http://www.ibm.com/support/knowledgecenter/SSEPGG_10.5.0/com.ibm.db2.luw.admin.perf.doc/doc/r0005274.html]

You will see that NS and X are not compatible. However, I am using WITH UR in my SELECT. The IBM DB2 documentation states:

https://www.ibm.com/support/knowledgecenter/SSEPGG_10.5.0/com.ibm.db2.luw.admin.perf.doc/doc/c0005270.html [https://www.ibm.com/support/knowledgecenter/SSEPGG_10.5.0/com.ibm.db2.luw.admin.perf.doc/doc/c0005270.html]

"The lock owner can both read and update data in the locked object. Only uncommitted read (UR) applications can access the locked object."

If you review the isolation levels @ https://www.ibm.com/support/knowledgecenter/SSEPGG_10.5.0/com.ibm.db2.luw.admin.perf.doc/doc/c0004121.html [https://www.ibm.com/support/knowledgecenter/SSEPGG_10.5.0/com.ibm.db2.luw.admin.perf.doc/doc/c0004121.html], you can see it states too:

"Under an X lock, concurrent application processes are prevented from accessing the data in any way. This does not apply to application processes with an isolation level of uncommitted read (UR), which can read but not modify the data."

This should mean that my SELECT WITH UR shouldn't be locked out, right? Not necessarily. The answer is in the type of cursor being used. One can recreate this situation like so:

db2 create db foo
db2 update db cfg for foo using locktimeout 3
db2set DB2_CAPTURE_LOCKTIMEOUT=ON
db2stop
db2start
db2 connect to foo
db2 "create table t1 (c1 integer)"
db2 "insert into t1 values (1)"
db2 "call set_routine_opts ('ISOLATION UR BLOCKING NO')"
db2 -v "create procedure p1(in v1 int) specific p1 dynamic result sets 1 language sql begin declare c1 cursor with return to client for select * from t1 where c1 = v1; open c1; end"

#session 2:
-----------
db2 connect to foo
db2 +c "update t1 set c1 = 2"

#session 1:
-----------

db2 "call p1(1)"
SQL0911N The current transaction has been rolled back because of a deadlock or timeout. Reason code "68". SQLSTATE=40001

Now that I've recreated the lock timeout, let's review why this is occuring.

Let's find the package associated with this stored procedure:

db2 "select BNAME from syscat.routinedep where routinename='P1'" 

BNAME
----------------------------
P1574696306
T1

Now let's see what the package details are:

db2 "select ISOLATION, BLOCKING from syscat.packages where PKGNAME='P1574696306'"

ISOLATION BLOCKING
--------- --------
UR N

The BLOCKING value is what is causing the lock in this case. A value of ALL or NO will cause the lock.


ANSWER
So instead I will declare my cursor differently. Because if you look at the DECLARE CURSOR statement, you will see an INSENSITIVE option: 


https://www.ibm.com/support/knowledgecenter/SSEPGG_10.5.0/com.ibm.db2.luw.sql.ref.doc/doc/r0000937.html [https://www.ibm.com/support/knowledgecenter/SSEPGG_10.5.0/com.ibm.db2.luw.sql.ref.doc/doc/r0000937.html]

db2 drop procedure p1 
db2 -v "create procedure p1(in v1 int) specific p1 dynamic result sets 1 language sql begin declare c1 INSENSITIVE cursor with return to client for select * from t1 where c1 = v1; open c1; end"

Now my select completes successfully.

RELATED INFORMATION
 Lock type compatibility [http://www.ibm.com/support/knowledgecenter/SSEPGG_10.5.0/com.ibm.db2.luw.admin.perf.doc/doc/r0005274.html]
Lock attributes [https://www.ibm.com/support/knowledgecenter/SSEPGG_10.5.0/com.ibm.db2.luw.admin.perf.doc/doc/c0005270.html]
Isolation levels [https://www.ibm.com/support/knowledgecenter/SSEPGG_10.5.0/com.ibm.db2.luw.admin.perf.doc/doc/c0004121.html]
DECLARE CURSOR statement [https://www.ibm.com/support/knowledgecenter/SSEPGG_10.5.0/com.ibm.db2.luw.sql.ref.doc/doc/r0000937.html]
BIND command [http://www.ibm.com/support/knowledgecenter/SSEPGG_10.5.0/com.ibm.db2.luw.admin.cmd.doc/doc/r0001935.html ]